<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Super Mario Mobile</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #87CEEB;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            height: 100vh;
            user-select: none;
            -webkit-user-select: none;
        }

        #gameContainer {
            position: relative;
            width: 100vw;
            height: 100vh;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            touch-action: none;
        }

        #controls {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            z-index: 100;
        }

        .control-btn {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            border: 3px solid #fff;
            background: rgba(255, 255, 255, 0.3);
            backdrop-filter: blur(10px);
            color: #fff;
            font-size: 28px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            user-select: none;
            transition: all 0.2s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .control-btn:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.5);
        }

        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            z-index: 100;
            background-color: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 10px;
            backdrop-filter: blur(5px);
        }

        #gameOver, #startScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            z-index: 200;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        #gameOver h2, #startScreen h1 {
            font-size: 36px;
            margin-bottom: 20px;
            color: #ff6b6b;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #gameOver p, #startScreen p {
            font-size: 20px;
            margin-bottom: 25px;
            line-height: 1.5;
        }

        .game-btn {
            padding: 15px 30px;
            font-size: 20px;
            background: #4CAF50;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            transition: all 0.3s;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .game-btn:hover {
            background: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        .game-btn:active {
            transform: translateY(0);
        }

        .health-bar {
            position: absolute;
            top: 70px;
            left: 20px;
            display: flex;
            gap: 8px;
            z-index: 100;
        }

        .heart {
            width: 30px;
            height: 30px;
            background-color: #FF5252;
            clip-path: path('M12,21.35L10.55,20.03C5.4,15.36 2,12.27 2,8.5C2,5.41 4.42,3 7.5,3C9.24,3 10.91,3.81 12,5.08C13.09,3.81 14.76,3 16.5,3C19.58,3 22,5.41 22,8.5C22,12.27 18.6,15.36 13.45,20.03L12,21.35Z');
            filter: drop-shadow(0 2px 3px rgba(0, 0, 0, 0.4));
        }

        .pause-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background: rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            z-index: 100;
            backdrop-filter: blur(5px);
        }

        .pause-btn::before, .pause-btn::after {
            content: "";
            position: absolute;
            width: 5px;
            height: 20px;
            background: white;
            border-radius: 3px;
        }

        .pause-btn::before {
            transform: translateX(-5px);
        }

        .pause-btn::after {
            transform: translateX(5px);
        }

        .pause-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 150;
            backdrop-filter: blur(5px);
            display: none;
        }

        .pause-content {
            background: rgba(255, 255, 255, 0.9);
            padding: 30px;
            border-radius: 15px;
            text-align: center;
        }

        .pause-content h2 {
            font-size: 32px;
            margin-bottom: 20px;
            color: #333;
        }

        @media (max-width: 768px) {
            .control-btn {
                width: 70px;
                height: 70px;
                font-size: 24px;
                gap: 20px;
            }
            
            #score {
                font-size: 18px;
                top: 15px;
                left: 15px;
            }

            .heart {
                width: 25px;
                height: 25px;
            }
        }

        @media (max-width: 480px) {
            .control-btn {
                width: 60px;
                height: 60px;
                font-size: 20px;
                gap: 15px;
            }

            #controls {
                bottom: 20px;
            }
            
            #gameOver h2, #startScreen h1 {
                font-size: 28px;
            }
            
            #gameOver p, #startScreen p {
                font-size: 16px;
            }
            
            .game-btn {
                padding: 12px 24px;
                font-size: 18px;
            }
        }

        /* Animações */
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        @keyframes coin-spin {
            0% { transform: scale(1); }
            50% { transform: scale(0.5); }
            100% { transform: scale(1); }
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        @media (max-width: 480px) {
            .control-btn {
                width: 70px;
                height: 70px;
                font-size: 20px;
            }
            
            #score {
                font-size: 20px;
                top: 15px;
                left: 15px;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="score">Pontos: 0 | Recorde: 0 | Vidas: 3</div>
        <div class="health-bar" id="healthBar"></div>
        
        <div id="controls">
            <div class="control-btn" id="leftBtn">←</div>
            <div class="control-btn" id="jumpBtn">↑</div>
            <div class="control-btn" id="rightBtn">→</div>
        </div>

        <div class="pause-btn" id="pauseBtn"></div>
        
        <div class="pause-screen" id="pauseScreen">
            <div class="pause-content">
                <h2>PAUSADO</h2>
                <button class="game-btn" id="resumeBtn">CONTINUAR</button>
            </div>
        </div>

        <div id="startScreen">
            <h1>Super Mario Mobile</h1>
            <p>Pule sobre obstáculos e colete moedas!</p>
            <p>Use as setas ou botões na tela para jogar</p>
            <button class="game-btn" id="startBtn">INICIAR JOGO</button>
        </div>

        <div id="gameOver" style="display: none;">
            <h2>Game Over!</h2>
            <p>Pontuação: <span id="finalScore">0</span></p>
            <button class="game-btn" id="restartBtn">Jogar Novamente</button>
        </div>
    </div>

    <script>
        class MarioGame {
            constructor() {
                this.canvas = document.getElementById('gameCanvas');
                this.ctx = this.canvas.getContext('2d');
                this.scoreElement = document.getElementById('score');
                this.gameOverElement = document.getElementById('gameOver');
                this.finalScoreElement = document.getElementById('finalScore');
                this.startScreenElement = document.getElementById('startScreen');
                this.healthBarElement = document.getElementById('healthBar');
                this.pauseScreenElement = document.getElementById('pauseScreen');
                
                // Sons básicos (simples beeps)
                this.sounds = {
                    jump: this.createBeep(800, 0.1),
                    coin: this.createBeep(1200, 0.2),
                    gameOver: this.createBeep(300, 0.5),
                    hit: this.createBeep(200, 0.15)
                };
                
                this.resizeCanvas();
                window.addEventListener('resize', () => this.resizeCanvas());
                
                this.gameRunning = false;
                this.gamePaused = false;
                this.setupControls();
                this.init();
                
                // Não iniciar o jogo automaticamente, mostrar tela inicial
                document.getElementById('startBtn').addEventListener('click', () => {
                    this.startGame();
                });
                
                // Loop de animação inicial
                this.animateMenu();
            }
            
            startGame() {
                this.startScreenElement.style.display = 'none';
                this.gameOverElement.style.display = 'none';
                this.init();
                
                // Aguardar um frame para garantir que tudo foi carregado
                requestAnimationFrame(() => {
                    this.gameRunning = true;
                    this.gamePaused = false;
                    
                    // Executar validação completa antes de iniciar
                    this.validateGame();
                    
                    console.log("Jogo iniciado com mundo completo!");
                    this.gameLoop();
                });
            }
            
            pauseGame() {
                if (this.gameRunning) {
                    this.gamePaused = !this.gamePaused;
                    if (this.gamePaused) {
                        this.pauseScreenElement.style.display = 'flex';
                    } else {
                        this.pauseScreenElement.style.display = 'none';
                    }
                }
            }

            resizeCanvas() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                this.groundY = this.canvas.height - 100;
            }

            createBeep(frequency, duration) {
                return () => {
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.frequency.value = frequency;
                        oscillator.type = 'square';
                        
                        gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
                        gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                        
                        oscillator.start(audioContext.currentTime);
                        oscillator.stop(audioContext.currentTime + duration);
                    } catch (e) {
                        // Som não suportado no navegador
                    }
                };
            }

            init() {
                this.mario = {
                    x: 100,
                    y: this.groundY - 50,
                    width: 40,
                    height: 50,
                    velocityY: 0,
                    velocityX: 0,
                    isJumping: false,
                    onGround: true,
                    speed: 5,
                    invulnerable: 0,
                    frame: 0,
                    frameTime: 0,
                    frames: 4,
                    direction: 1, // 1 = direita, -1 = esquerda
                    jumpHoldTime: 0,
                    inWater: false,
                    powered: false
                };

                this.obstacles = [];
                this.coins = [];
                this.blocks = []; // Novo array para blocos interativos
                this.platforms = []; // Novo array para plataformas
                this.pipes = []; // Novo array para tubos
                this.powerUps = []; // Novo array para power-ups
                
                // Sistema de câmera e mundo
                this.worldPosition = 0; // Posição total do mundo
                this.worldWidth = 5400; // Reduzido de 10800 para 5400 (metade)
                this.cameraX = 0; // Posição X da câmera
                this.lastTime = Date.now(); // Para deltaTime
                
                // Sistema de grade para posicionamento de elementos
                this.gridSize = 40;
                this.lastHitBlock = null;
                
                // Definir modo de renderização para mundo pré-gerado em vez de dinâmico
                this.preRenderedWorld = true;
                this.worldFullyGenerated = false;
                
                // Propriedades principais do jogo
                this.castle = null;
                this.flag = null;
                this.gameWon = false;
                this.lastKeys = {};
                
                // COORDENADOR GLOBAL DE ELEMENTOS
                this.elementSpawnMap = {
                    lastBlockX: 0,
                    lastEnemyX: 0,
                    lastPipeX: 0,
                    lastPlatformX: 0,
                    occupiedHeights: {}  // Mapa para controlar alturas já ocupadas
                };
                
                this.score = 0;
                this.lives = 3;
                this.gameRunning = true;
                this.obstacleTimer = 0;
                this.coinTimer = 0;
                this.backgroundX = 0;
                
                // Partículas
                this.particles = [];

                this.keys = {
                    left: false,
                    right: false,
                    up: false,
                    jump: false
                };

                // Recorde local
                this.highScore = localStorage.getItem('highScore') || 0;
                this.coinEffect = null;
                this.hitEffect = null;
                
                // Inicializar arrays limpos antes da geração
                this.platforms = [];
                this.blocks = [];
                this.pipes = [];
                this.coins = [];
                this.obstacles = [];
                this.particles = [];
                
                // Forçar carregamento completo do mundo de uma vez
                this.forceFullWorldGeneration();
                
                // Aplicar todas as correções imediatamente após a geração
                this.applyAllFixes();
                
                // Executar limpeza agressiva de objetos invisíveis
                this.eliminateInvisibleObjects();
                
                // Marcar mundo como totalmente gerado
                this.worldFullyGenerated = true;
                
                this.updateScoreDisplay();
                this.updateHealthBar();
            }
            
            updateHealthBar() {
                this.healthBarElement.innerHTML = '';
                for (let i = 0; i < this.lives; i++) {
                    const heart = document.createElement('div');
                    heart.className = 'heart';
                    this.healthBarElement.appendChild(heart);
                }
            }

            // Método para gerar o mundo completo com elementos no estilo Mario original
            generateWorld() {
                // Limpar arrays existentes
                this.platforms = [];
                this.blocks = [];
                this.pipes = [];
                this.coins = [];
                this.obstacles = [];
                
                // Gerar nuvens com detalhes
                this.clouds = [];
                for (let i = 0; i < 15; i++) {
                    const width = 60 + Math.random() * 60;
                    const height = 30 + Math.random() * 20;
                    const opacity = 0.7 + Math.random() * 0.3;
                    
                    // Posição inicial espalhada pelo mundo
                    const x = Math.random() * this.worldWidth;
                    const y = 30 + Math.random() * 120;
                    
                    // Velocidade lenta e variada
                    const speed = 0.1 + Math.random() * 0.3;
                    
                    // Detalhes (sub-nuvens) para tornar mais realistas
                    const details = [];
                    const numDetails = 3 + Math.floor(Math.random() * 3);
                    
                    for (let j = 0; j < numDetails; j++) {
                        details.push({
                            x: width * (0.2 + Math.random() * 0.6),
                            y: height * (0.2 + Math.random() * 0.6),
                            width: width * (0.3 + Math.random() * 0.4),
                            height: height * (0.3 + Math.random() * 0.4)
                        });
                    }
                    
                    this.clouds.push({x, y, width, height, opacity, speed, details});
                }
                
                // Gerar plataformas em posições estratégicas com mais espaçamento
                const platformPositions = [
                    {x: 600, y: this.groundY - 150, width: 200},   // Aumentado de 500 para 600
                    {x: 1000, y: this.groundY - 120, width: 150}, // Aumentado de 800 para 1000
                    {x: 1500, y: this.groundY - 180, width: 250}, // Aumentado de 1200 para 1500
                    {x: 2000, y: this.groundY - 140, width: 180}, // Aumentado de 1600 para 2000
                    {x: 2500, y: this.groundY - 160, width: 220}, // Mantido 2000 -> 2500
                    {x: 3000, y: this.groundY - 130, width: 180}, // Aumentado de 2500 para 3000
                    {x: 3600, y: this.groundY - 200, width: 240}  // Aumentado de 3000 para 3600
                ];
                
                platformPositions.forEach(pos => {
                    this.platforms.push({
                        x: pos.x,
                        y: pos.y,
                        width: pos.width,
                        height: 20,
                        speed: 0 // Plataformas não se movem mais
                    });
                });
                
                // Gerar blocos em formações interessantes com mais espaçamento
                // 1. Blocos individuais
                const singleBlocks = [
                    {x: 500, y: this.groundY - 200},  // Aumentado de 400 para 500
                    {x: 900, y: this.groundY - 240},  // Aumentado de 700 para 900
                    {x: 1350, y: this.groundY - 220}, // Aumentado de 1150 para 1350
                    {x: 2100, y: this.groundY - 180}, // Aumentado de 1800 para 2100
                    {x: 2600, y: this.groundY - 200}  // Aumentado de 2200 para 2600
                ];
                
                singleBlocks.forEach(pos => {
                    this.blocks.push({
                        x: pos.x,
                        y: pos.y,
                        width: 40,
                        height: 40,
                        speed: 0, // Blocos não se movem mais
                        type: 'question',
                        hit: false,
                        bounceY: 0,
                        bounceSpeed: 0
                    });
                });
                
                // 2. Linhas horizontais de blocos - reduzidas
                const blockLines = [
                    {startX: 900, y: this.groundY - 180, count: 2},  // Reduzido de 3 para 2
                    {startX: 1400, y: this.groundY - 200, count: 2}, // Reduzido de 4 para 2
                    {startX: 2600, y: this.groundY - 220, count: 3}  // Reduzido de 5 para 3
                ];
                
                blockLines.forEach(line => {
                    for (let i = 0; i < line.count; i++) {
                        const blockType = (i % 3 === 1) ? 'question' : 'brick';
                        this.blocks.push({
                            x: line.startX + (i * 50),
                            y: line.y,
                            width: 40,
                            height: 40,
                            speed: 0,
                            type: blockType,
                            hit: false,
                            bounceY: 0,
                            bounceSpeed: 0
                        });
                    }
                });
                
                // Gerar tubos - Ajustado para mapa de 5400px
                const pipePositions = [
                    {x: 450, height: 80},   // Primeiro tubo
                    {x: 850, height: 120},  // Segundo tubo (mais alto)
                    {x: 1350, height: 100}, // Terceiro tubo
                    {x: 1950, height: 140}, // Tubo alto no meio
                    {x: 2650, height: 90},  // Tubo médio
                    {x: 3450, height: 110}, // Tubo próximo ao final
                    {x: 4200, height: 160}  // Tubo final (mais alto)
                ];
                
                pipePositions.forEach(pos => {
                    this.pipes.push({
                        x: pos.x,
                        y: this.groundY - pos.height,
                        width: 60,
                        height: pos.height,
                        speed: 0 // Tubos não se movem mais
                    });
                });
                
                // Gerar inimigos - Redistribuídos para mapa de 5400px
                const enemyPositions = [
                    {x: 350, type: 'goomba'},   // Primeiro inimigo
                    {x: 750, type: 'turtle'},   // Primeira tartaruga  
                    {x: 1150, type: 'goomba'},  // Segundo goomba
                    {x: 1550, type: 'jumping'}, // Primeiro saltador
                    {x: 2050, type: 'flying'},  // Primeiro voador
                    {x: 2450, type: 'goomba'},  // Terceiro goomba
                    {x: 2850, type: 'turtle'},  // Segunda tartaruga
                    {x: 3350, type: 'jumping'}, // Segundo saltador
                    {x: 3750, type: 'flying'},  // Segundo voador
                    {x: 4150, type: 'goomba'}   // Último inimigo antes do castelo
                ];
                
                enemyPositions.forEach(pos => {
                    let yPos;
                    
                    // Determinar posição Y baseada no tipo
                    if (pos.type === 'flying') {
                        yPos = this.groundY - 120 - Math.random() * 80;
                    } else {
                        yPos = this.groundY - 40;
                    }
                    
                    this.obstacles.push({
                        x: pos.x,
                        y: yPos,
                        width: 30,
                        height: 40,
                        speed: pos.type === 'turtle' ? 1 : 2, // Velocidades variadas
                        direction: 1, // 1 = direita, -1 = esquerda
                        type: pos.type,
                        jumpVelocity: pos.type === 'jumping' ? 0 : 0,
                        isJumping: false,
                        startY: yPos,
                        frame: 0,
                        frameTime: 0,
                        behavior: this.getEnemyBehavior(pos.type)
                    });
                });
                
                // Gerar moedas com mais espaçamento
                for (let i = 0; i < 30; i++) {
                    // Posições com mais espaçamento entre moedas
                    let coinX = 400 + (i * 300) + (Math.random() * 100); // Aumentado de 200 para 300, reduzido random de 150 para 100
                    let coinY;
                    
                    // 50% chance de colocar moeda no ar, 50% em plataformas
                    if (Math.random() < 0.5) {
                        coinY = this.groundY - 80 - Math.random() * 120;
                    } else {
                        // Tentar posicionar em cima de plataformas
                        const nearbyPlatform = this.platforms.find(p => 
                            Math.abs(p.x + p.width/2 - coinX) < p.width/2
                        );
                        
                        if (nearbyPlatform) {
                            coinY = nearbyPlatform.y - 40;
                        } else {
                            coinY = this.groundY - 80 - Math.random() * 80;
                        }
                    }
                    
                    this.coins.push({
                        x: coinX,
                        y: coinY,
                        width: 25,
                        height: 25,
                        speed: 0, // Moedas não se movem mais
                        angle: Math.random() * Math.PI * 2,
                        shine: Math.random() * 30
                    });
                }
                
                // Aplicar correções conhecidas para áreas específicas
                this.fixKnownLayoutIssues();
                
                // Implementar sistema de grade
                this.implementGridSystem();
                
                // Gerar blocos quebráveis
                this.generateBrickBlocks();
                
                // Garantir que existam blocos até o final do jogo
                this.ensureBricksToEnd();
                
                // Corrigir posicionamento de blocos sobre plataformas
                this.fixBlocksOverPlatforms();
                
                // Adicionar inimigos bem distribuídos
                this.addEvenlyDistributedEnemies();
                
                // Preencher áreas vazias com mais elementos
                this.fillEmptyAreas();
                
                // Verificar se o caminho é jogável e corrigir se necessário
                this.validateGameplayPath();
                
                // Ajustar todos os elementos à grade
                this.snapAllObjectsToGrid();
                
                // Validar e corrigir posicionamento dos elementos
                this.validateObjectPlacement();
                
                // Verificar todas as áreas do jogo para garantir jogabilidade
                this.validateAllGameplayAreas();
                
                // Adicionar desafios consistentes do meio ao final
                this.addMiddleToEndChallenges();
                
                // Gerar área final (castelo e bandeira)
                this.generateEndArea();
            }

            // Método para limpar código problemático que atrapalha a lógica - VERSÃO EXPANDIDA
            cleanupProblematicCode() {
                // ------ REMOVER SISTEMAS DESNECESSÁRIOS ------
                
                // Desabilitar sistemas desnecessários
                this.drawWater = function() { return; };
                this.checkWaterCollision = function() { return; };
                this.generateWaterAreas = function() { return; };
                
                // Desabilitar sistemas de geração dinâmica
                this.dynamicLoading = false;
                this.lastGeneratedX = undefined;
                this.generationQueue = undefined;
                this.generateChunks = function() { return; };
                
                // 3. Desabilitar funções de spawn dinâmico
                this.spawnObstacle = function() { return; };
                this.spawnBlock = function() { return; };
                this.generateEnvironment = function() { return; };
                
                // 4. Limpar variáveis de tracking desnecessárias
                this.blocksToGenerate = [];
                this.enemiesToGenerate = [];
                this.platformsToGenerate = [];
                this.objectsToRemove = [];
                this.generationPoints = [];
                
                // 5. Consertar problemas de renderização
                this.renderDistance = this.canvas.width + 200;
                this.cullObjectsFarFromCamera = false; // Desativar remoção de objetos fora da tela
                
                // ------ LOG DE LIMPEZA ------
                console.log("🧹 Código problemático removido com sucesso!");
                console.log("✅ Sistema de água removido");
                console.log("✅ Geração dinâmica desativada");
                console.log("✅ Spawn dinâmico desativado");
                console.log("✅ Remoção de objetos fora da tela desativada");
            }

            // Corrigir DEFINITIVAMENTE os canos flutuantes
            fixAllPipesPosition() {
                // 1. Garantir que TODOS os canos toquem o chão
                if (this.pipes && this.pipes.length > 0) {
                    this.pipes.forEach(pipe => {
                        pipe.y = this.groundY - pipe.height;
                    });
                    console.log("✅ Posição de todos os canos corrigida!");
                }
                
                // 2. Sobrescrever completamente o método de criação de canos
                this.createPipe = function(x, height) {
                    this.pipes.push({
                        x: x,
                        y: this.groundY - height, // SEMPRE no chão
                        width: 60,
                        height: height,
                        speed: 0
                    });
                };
                
                // 3. Verificar todos os métodos que geram canos
                const pipeMethods = ['generatePipes', 'addPipes', 'createPipes'];
                
                // Substituir qualquer método existente que cria canos
                pipeMethods.forEach(methodName => {
                    if (typeof this[methodName] === 'function') {
                        const originalMethod = this[methodName];
                        this[methodName] = (...args) => {
                            originalMethod.apply(this, args);
                            this.fixAllPipesPosition(); // Garantir posição correta após criação
                        };
                    }
                });
                
                console.log("🔧 Métodos de criação de canos corrigidos");
            }

            // Eliminar COMPLETAMENTE toda geração dinâmica
            eliminateDynamicGeneration() {
                // 1. Remover completamente todos os métodos de geração dinâmica
                const dynamicMethods = [
                    'generateChunks', 'spawnObstacle', 'spawnBlock', 'generateEnvironment',
                    'dynamicObjectGeneration', 'queueGeneration', 'processPendingGeneration',
                    'dynamicallyLoadContent', 'generateChunk', 'generateDynamicSection'
                ];
                
                // Substituir todos por funções vazias
                dynamicMethods.forEach(method => {
                    this[method] = function() { return; };
                });
                
                // 2. Desativar flags de geração dinâmica
                this.dynamicLoading = false;
                this.dynamicGeneration = false;
                this.generateChunks = false;
                this.useDynamicLoading = false;
                this.pendingGeneration = false;
                
                // 3. Limpar arrays de geração
                const dynamicArrays = [
                    'chunksToGenerate', 'pendingObjects', 'generationQueue',
                    'objectsToGenerate', 'blocksToGenerate', 'enemiesToGenerate',
                    'platformsToGenerate', 'pipesToGenerate', 'generationPoints'
                ];
                
                // Zerar arrays
                dynamicArrays.forEach(array => {
                    if (this[array]) this[array] = [];
                });
                
                console.log("🚫 Geração dinâmica completamente eliminada");
            }

            // Método aprimorado para eliminar objetos dinâmicos invisíveis
            eliminateInvisibleObjects() {
                console.log("🔍 Iniciando limpeza profunda de objetos invisíveis...");
                
                // Remover objetos que estão fora dos limites do mundo
                const worldLimit = this.worldWidth || 5400;
                
                // Contar objetos antes da limpeza
                const originalCounts = {
                    obstacles: this.obstacles?.length || 0,
                    blocks: this.blocks?.length || 0,
                    platforms: this.platforms?.length || 0,
                    pipes: this.pipes?.length || 0,
                    coins: this.coins?.length || 0
                };
                
                // Filtrar arrays com critérios mais rigorosos
                if (Array.isArray(this.obstacles)) {
                    this.obstacles = this.obstacles.filter(obj => 
                        obj && 
                        obj.x >= -50 && obj.x <= worldLimit + 50 && 
                        obj.y >= 0 && obj.y <= this.groundY + 50 && 
                        typeof obj.width === 'number' && typeof obj.height === 'number' &&
                        obj.width > 0 && obj.height > 0 &&
                        obj.type // Garantir que tem um tipo definido
                    );
                }
                
                if (Array.isArray(this.blocks)) {
                    this.blocks = this.blocks.filter(obj => 
                        obj && 
                        obj.x >= -50 && obj.x <= worldLimit + 50 && 
                        obj.y >= 0 && obj.y <= this.groundY && 
                        typeof obj.width === 'number' && typeof obj.height === 'number' &&
                        obj.width > 0 && obj.height > 0 &&
                        obj.type // Garantir que tem um tipo definido
                    );
                }
                
                if (Array.isArray(this.platforms)) {
                    this.platforms = this.platforms.filter(obj => 
                        obj && 
                        obj.x >= -50 && obj.x <= worldLimit + 50 && 
                        obj.y >= 0 && obj.y <= this.groundY && 
                        typeof obj.width === 'number' && typeof obj.height === 'number' &&
                        obj.width > 0 && obj.height > 0
                    );
                }
                
                if (Array.isArray(this.pipes)) {
                    this.pipes = this.pipes.filter(obj => 
                        obj && 
                        obj.x >= -50 && obj.x <= worldLimit + 50 && 
                        obj.y >= 0 && obj.y <= this.groundY && 
                        typeof obj.width === 'number' && typeof obj.height === 'number' &&
                        obj.width > 0 && obj.height > 0
                    );
                }
                
                if (Array.isArray(this.coins)) {
                    this.coins = this.coins.filter(obj => 
                        obj && 
                        obj.x >= -50 && obj.x <= worldLimit + 50 && 
                        obj.y >= 0 && obj.y <= this.groundY && 
                        typeof obj.width === 'number' && typeof obj.height === 'number' &&
                        obj.width > 0 && obj.height > 0
                    );
                }
                
                // Limpar partículas inválidas
                if (Array.isArray(this.particles)) {
                    this.particles = this.particles.filter(particle => 
                        particle && 
                        particle.x >= -100 && particle.x <= worldLimit + 100 && 
                        particle.y >= 0 && particle.y <= this.canvas.height
                    );
                }
                
                // Remover completamente objetos dinamicamente gerados
                this.animatedCoins = [];
                this.generationQueue = [];
                this.pendingObjects = [];
                
                // Eliminar objetos duplicados com verificação mais rigorosa
                this.removeDuplicateObjectsStrict();
                
                console.log(`✅ Limpeza profunda de objetos invisíveis concluída:
       - Obstáculos: ${originalCounts.obstacles} → ${this.obstacles?.length || 0}
       - Blocos: ${originalCounts.blocks} → ${this.blocks?.length || 0}
       - Plataformas: ${originalCounts.platforms} → ${this.platforms?.length || 0}
       - Canos: ${originalCounts.pipes} → ${this.pipes?.length || 0}
       - Moedas: ${originalCounts.coins} → ${this.coins?.length || 0}`);
            }

            // Método para remover objetos duplicados
            removeDuplicateObjects() {
                const tolerance = 5; // Tolerância de pixels para considerar objetos duplicados
                
                // Remover duplicatas de obstáculos
                if (Array.isArray(this.obstacles)) {
                    this.obstacles = this.obstacles.filter((obj, index, array) => {
                        return !array.slice(0, index).some(other => 
                            Math.abs(obj.x - other.x) < tolerance && 
                            Math.abs(obj.y - other.y) < tolerance
                        );
                    });
                }
                
                // Remover duplicatas de blocos
                if (Array.isArray(this.blocks)) {
                    this.blocks = this.blocks.filter((obj, index, array) => {
                        return !array.slice(0, index).some(other => 
                            Math.abs(obj.x - other.x) < tolerance && 
                            Math.abs(obj.y - other.y) < tolerance
                        );
                    });
                }
                
                // Remover duplicatas de plataformas
                if (Array.isArray(this.platforms)) {
                    this.platforms = this.platforms.filter((obj, index, array) => {
                        return !array.slice(0, index).some(other => 
                            Math.abs(obj.x - other.x) < tolerance && 
                            Math.abs(obj.y - other.y) < tolerance
                        );
                    });
                }
                
                console.log("🧹 Objetos duplicados removidos");
            }

            // Método aprimorado para remover objetos duplicados com tolerância menor
            removeDuplicateObjectsStrict() {
                const tolerance = 3; // Tolerância de pixels reduzida para detecção mais rigorosa
                
                // Remover duplicatas de obstáculos
                if (Array.isArray(this.obstacles)) {
                    this.obstacles = this.obstacles.filter((obj, index, array) => {
                        return !array.slice(0, index).some(other => 
                            Math.abs(obj.x - other.x) < tolerance && 
                            Math.abs(obj.y - other.y) < tolerance &&
                            obj.type === other.type
                        );
                    });
                }
                
                // Remover duplicatas de blocos
                if (Array.isArray(this.blocks)) {
                    this.blocks = this.blocks.filter((obj, index, array) => {
                        return !array.slice(0, index).some(other => 
                            Math.abs(obj.x - other.x) < tolerance && 
                            Math.abs(obj.y - other.y) < tolerance &&
                            obj.type === other.type
                        );
                    });
                }
                
                // Remover duplicatas de plataformas que se sobrepõem completamente
                if (Array.isArray(this.platforms)) {
                    this.platforms = this.platforms.filter((obj, index, array) => {
                        return !array.slice(0, index).some(other => 
                            Math.abs(obj.x - other.x) < tolerance && 
                            Math.abs(obj.y - other.y) < tolerance &&
                            Math.abs(obj.width - other.width) < tolerance
                        );
                    });
                }
                
                // Remover duplicatas de canos
                if (Array.isArray(this.pipes)) {
                    this.pipes = this.pipes.filter((obj, index, array) => {
                        return !array.slice(0, index).some(other => 
                            Math.abs(obj.x - other.x) < tolerance && 
                            Math.abs(obj.height - other.height) < tolerance
                        );
                    });
                }
                
                console.log("🧹 Objetos duplicados removidos com critérios rigorosos");
            }

            // Método para forçar geração completa do mundo
            forceFullWorldGeneration() {
                console.log("🌎 Iniciando geração completa do mundo...");
                
                // 1. Limpar arrays para evitar duplicação
                this.platforms = this.platforms || [];
                this.blocks = this.blocks || [];
                this.pipes = this.pipes || [];
                this.coins = this.coins || [];
                this.obstacles = this.obstacles || [];
                
                // 2. Gerar mundo completo
                this.generateWorld();
                
                // 3. Corrigir posições dos elementos
                this.fixAllPipesPosition();
                
                console.log("✅ Mundo completo gerado!");
                console.log(`📊 Elementos: ${this.platforms.length} plataformas, ${this.blocks.length} blocos, ${this.pipes.length} canos, ${this.coins.length} moedas, ${this.obstacles.length} inimigos`);
            }

            // Corrigir física independente da posição da câmera
            fixCameraIndependentPhysics() {
                // 1. Método auxiliar para garantir processamento independente da câmera
                this.ensureAllElementsProcessed = function() {
                    // Garantir que nenhum elemento seja filtrado pela câmera
                    this.cullObjectsFarFromCamera = false;
                    
                    // Garantir que todos os blocos sejam atualizados
                    if (this.blocks && this.updateBlocks) {
                        this.updateBlocks(0.016); // deltaTime aproximado
                    }
                };
                
                // 2. Reforçar método de update para NÃO depender da câmera
                const originalUpdate = this.update;
                if (originalUpdate) {
                    this.update = function(deltaTime) {
                        // Chamar update original
                        originalUpdate.call(this, deltaTime);
                        
                        // Garantir que todos os elementos sejam processados,
                        // independente da posição da câmera
                        this.ensureAllElementsProcessed();
                    };
                }
                
                console.log("📐 Física independente da câmera configurada");
            }

            // Corrigir posição da bandeira e castelo
            adjustFlagAndCastlePosition() {
                // Verificar se castle e flag existem
                if (!this.castle || !this.flag) {
                    console.warn("⚠️ Castelo ou bandeira não encontrados!");
                    return;
                }
                
                // 1. Ajustar posição do castelo para o final do nível
                const endX = this.worldWidth - 350;
                
                // 2. Reposicionar o castelo
                this.castle.x = endX;
                this.castle.y = this.groundY - this.castle.height;
                
                // 3. Mover a bandeira para ficar mais próxima ao castelo (à direita)
                this.flag.x = endX - 60; // Mais próxima ao castelo
                this.flag.y = this.groundY - this.flag.height;
                
                console.log("🏰 Castelo reposicionado para x:", endX);
                console.log("🚩 Bandeira reposicionada para x:", this.flag.x);
            }

            // Aplicar todas as correções de uma vez
            applyAllFixes() {
                console.log("🛠️ Aplicando todas as correções...");
                
                // 1. Eliminar geração dinâmica primeiro
                this.eliminateDynamicGeneration();
                
                // Remover objetos invisíveis ou inválidos
                this.eliminateInvisibleObjects();
                
                // Corrigir física com movimento de câmera
                this.fixCameraIndependentPhysics();
                
                // 5. Corrigir posição dos canos
                this.fixAllPipesPosition();
                
                // 6. Ajustar posição do castelo e bandeira
                this.adjustFlagAndCastlePosition();
                
                // 7. Remover código problemático
                this.cleanupProblematicCode();
                
                console.log("✅ Todas as correções aplicadas com sucesso!");
            }

            // Método para alinhar todos os objetos ao grid
            snapAllObjectsToGrid() {
                const gridSize = 20; // Grid de 20px
                
                // Alinhar plataformas
                this.platforms.forEach(platform => {
                    platform.x = Math.round(platform.x / gridSize) * gridSize;
                    platform.y = Math.round(platform.y / gridSize) * gridSize;
                });
                
                // Alinhar blocos
                this.blocks.forEach(block => {
                    block.x = Math.round(block.x / gridSize) * gridSize;
                    block.y = Math.round(block.y / gridSize) * gridSize;
                });
                
                // Alinhar canos (X no grid, Y sempre no chão)
                this.pipes.forEach(pipe => {
                    pipe.x = Math.round(pipe.x / gridSize) * gridSize;
                    pipe.y = this.groundY - pipe.height;
                });
                
                console.log("Objetos alinhados ao grid");
            }

            // Método para corrigir sobreposições de objetos
            fixOverlappingObjects() {
                const checkAndFixOverlap = (objA, objB, minDistance = 60) => {
                    if (objA.x < objB.x + objB.width &&
                        objA.x + objA.width > objB.x &&
                        objA.y < objB.y + objB.height &&
                        objA.y + objA.height > objB.y) {
                        
                        const overlapX = Math.min(
                            objA.x + objA.width - objB.x,
                            objB.x + objB.width - objA.x
                        );
                        
                        if (objA.x < objB.x) {
                            objA.x -= overlapX + minDistance;
                        } else {
                            objA.x += overlapX + minDistance;
                        }
                    }
                };
                
                // Verificar plataformas vs. canos
                this.platforms.forEach(platform => {
                    this.pipes.forEach(pipe => {
                        checkAndFixOverlap(platform, pipe);
                    });
                });
                
                // Verificar plataformas vs. blocos
                this.platforms.forEach(platform => {
                    this.blocks.forEach(block => {
                        checkAndFixOverlap(platform, block);
                    });
                });
                
                console.log("Sobreposições corrigidas");
            }

            // Método para garantir carregamento completo do mundo
            forceCompleteWorldGeneration() {
                // Limpar todos os arrays para evitar duplicação
                this.platforms = [];
                this.blocks = [];
                this.pipes = [];
                this.coins = [];
                this.obstacles = [];
                this.particles = [];
                
                // Desativar geração dinâmica
                this.dynamicWorldGeneration = false;
                
                // Gerar mundo completo
                this.generateWorld();
                
                // Aplicar todas as correções
                this.fixPipesPositioning();
                this.optimizePlatforms();
                this.cleanupProblematicCode();
                this.snapAllObjectsToGrid();
                this.fixOverlappingObjects();
                
                console.log("Mundo completo gerado!");
                console.log(`Elementos: ${this.platforms.length} plataformas, ${this.blocks.length} blocos, ${this.pipes.length} canos, ${this.obstacles.length} inimigos, ${this.coins.length} moedas`);
            }

            // Sistema de água removido - não é mais utilizado

            // Novo método para adicionar plataformas extras no lugar da água
            addExtraPlatforms() {
                // Adicionar plataformas extras nos locais onde havia água antes
                const platformPositions = [
                    {x: 2500, y: this.groundY - 100, width: 150},
                    {x: 3000, y: this.groundY - 120, width: 180},
                    {x: 3500, y: this.groundY - 90, width: 140},
                    {x: 4000, y: this.groundY - 110, width: 160}
                ];
                
                platformPositions.forEach(pos => {
                    this.platforms.push({
                        x: pos.x,
                        y: pos.y,
                        width: pos.width,
                        height: 20,
                        speed: 0
                    });
                    
                    // Adicionar algumas moedas acima das plataformas
                    for (let i = 0; i < 3; i++) {
                        this.coins.push({
                            x: pos.x + 20 + (i * 40),
                            y: pos.y - 50,
                            width: 25,
                            height: 25,
                            speed: 0,
                            angle: 0,
                            shine: Math.random() * 30
                        });
                    }
                });
            }

            // Método para adicionar maneiras de atravessar a água
            addWaterCrossings() {
                this.waterAreas.forEach(water => {
                    // Plataformas com movimento vertical mais desafiadoras
                    const numPlatforms = Math.ceil(water.width / 100);
                    const gap = water.width / (numPlatforms + 1);
                    
                    for (let i = 0; i < numPlatforms; i++) {
                        // Plataformas menores com espaçamento maior e movimento
                        this.platforms.push({
                            x: water.x + ((i + 1) * gap),
                            y: this.groundY - 70 - (i % 2) * 20,
                            width: 50,
                            height: 15,
                            speed: 0,
                            moveY: true, // Plataforma que se move para cima e para baixo
                            moveRange: 30,
                            moveSpeed: 0.5 + Math.random() * 0.5,
                            moveDir: 1,
                            origY: this.groundY - 70 - (i % 2) * 20
                        });
                        
                        // Adicionar inimigo em algumas plataformas
                        if (i % 2 === 0) {
                            this.obstacles.push({
                                x: water.x + ((i + 1) * gap) + 10,
                                y: this.groundY - 110 - (i % 2) * 20,
                                width: 30,
                                height: 30,
                                speed: 2,
                                direction: 1,
                                type: 'goomba',
                                jumpVelocity: 0,
                                isJumping: false,
                                startY: this.groundY - 110 - (i % 2) * 20,
                                frame: 0,
                                frameTime: 0,
                                behavior: this.getEnemyBehavior('goomba'),
                                platformWidth: 50 // Limite para movimento
                            });
                        }
                        
                        // Chance de colocar moeda acima da plataforma - verificar posição
                        if (Math.random() < 0.7) {
                            const coinX = water.x + ((i + 1) * gap) + 15;
                            const coinY = this.groundY - 130 - (i % 2) * 20; // Mais acima
                            
                            if (this.isValidCoinPosition(coinX, coinY)) {
                                this.coins.push({
                                    x: coinX,
                                    y: coinY,
                                    width: 25,
                                    height: 25,
                                    speed: 0,
                                    angle: 0,
                                    shine: Math.random() * 30
                                });
                            }
                        }
                    }
                });
            }

            // Novo método para adicionar desafios consistentes até o final
            addMiddleToEndChallenges() {
                // Distribuir desafios em todo o mapa com mais espaçamento
                for (let x = 3000; x < this.worldWidth - 600; x += 600) { // Aumentado de 400 para 600
                    const challengeType = Math.random();
                    
                    if (challengeType < 0.3) {
                        // Plataformas elevadas com blocos
                        const platformY = this.groundY - 100 - Math.random() * 80;
                        const platformWidth = 100 + Math.random() * 100;
                        
                        this.platforms.push({
                            x: x,
                            y: platformY,
                            width: platformWidth,
                            height: 20,
                            speed: 0
                        });
                        
                        // Blocos acima da plataforma - reduzidos
                        const numBlocks = 1 + Math.floor(Math.random() * 2); // Reduzido de 3 para 2 máximo
                        for (let i = 0; i < numBlocks; i++) {
                            this.blocks.push({
                                x: x + 30 + (i * 70), // Aumentado de 20+(i*50) para 30+(i*70)
                                y: platformY - 80,
                                width: 40,
                                height: 40,
                                speed: 0,
                                type: Math.random() < 0.5 ? 'question' : 'brick',
                                hit: false,
                                bounceY: 0,
                                bounceSpeed: 0
                            });
                        }
                        
                        // Inimigo na plataforma
                        if (Math.random() < 0.6) {
                            const enemyType = Math.random() < 0.7 ? 'goomba' : 'turtle';
                            this.obstacles.push({
                                x: x + platformWidth/2,
                                y: platformY - 40,
                                width: 30,
                                height: 40,
                                speed: 1.5,
                                direction: Math.random() < 0.5 ? 1 : -1,
                                type: enemyType,
                                jumpVelocity: 0,
                                isJumping: false,
                                startY: platformY - 40,
                                frame: 0,
                                frameTime: 0,
                                behavior: this.getEnemyBehavior(enemyType),
                                platformWidth: platformWidth - 40 // Limite para movimento
                            });
                        }
                    }
                    else if (challengeType < 0.6) {
                        // Tubos com inimigos
                        const tubeHeight = 60 + Math.random() * 80;
                        
                        this.pipes.push({
                            x: x,
                            y: this.groundY - tubeHeight,
                            width: 60,
                            height: tubeHeight,
                            speed: 0
                        });
                        
                        // Inimigo em cima do tubo
                        if (Math.random() < 0.5) {
                            const enemyType = Math.random() < 0.6 ? 'goomba' : 
                                             (Math.random() < 0.8 ? 'turtle' : 'jumping');
                            this.obstacles.push({
                                x: x + 15,
                                y: this.groundY - tubeHeight - 40,
                                width: 30,
                                height: 40,
                                speed: enemyType === 'jumping' ? 2 : 1,
                                direction: 1,
                                type: enemyType,
                                jumpVelocity: enemyType === 'jumping' ? -8 : 0,
                                isJumping: false,
                                startY: this.groundY - tubeHeight - 40,
                                frame: 0,
                                frameTime: 0,
                                behavior: this.getEnemyBehavior(enemyType)
                            });
                        }
                        
                        // Moedas acima do tubo - verificar posicionamento
                        for (let i = 0; i < 3; i++) {
                            const coinX = x + 15 + (i * 20);
                            const coinY = this.groundY - tubeHeight - 100 - (i * 20); // Mais distante do tubo
                            
                            if (this.isValidCoinPosition(coinX, coinY)) {
                                this.coins.push({
                                    x: coinX,
                                    y: coinY,
                                    width: 25,
                                    height: 25,
                                    speed: 0,
                                    angle: 0,
                                    shine: Math.random() * 30
                                });
                            }
                        }
                    }
                    else {
                        // Formações de blocos complexas
                        const baseY = this.groundY - 120 - Math.random() * 60;
                        const pattern = Math.floor(Math.random() * 3);
                        
                        if (pattern === 0) {
                            // Padrão de escada
                            for (let i = 0; i < 4; i++) {
                                const blockType = i === 2 ? 'question' : 'brick';
                                this.blocks.push({
                                    x: x + (i * 40),
                                    y: baseY - (i * 40),
                                    width: 40,
                                    height: 40,
                                    speed: 0,
                                    type: blockType,
                                    hit: false,
                                    bounceY: 0,
                                    bounceSpeed: 0
                                });
                            }
                        } 
                        else if (pattern === 1) {
                            // Padrão em pirâmide
                            for (let i = 0; i < 3; i++) {
                                for (let j = 0; j < (3 - i); j++) {
                                    const blockType = (i === 1 && j === 0) ? 'question' : 'brick';
                                    this.blocks.push({
                                        x: x + (j * 40) + (i * 20),
                                        y: baseY - (i * 40),
                                        width: 40,
                                        height: 40,
                                        speed: 0,
                                        type: blockType,
                                        hit: false,
                                        bounceY: 0,
                                        bounceSpeed: 0
                                    });
                                }
                            }
                        }
                        else {
                            // Padrão em U invertido
                            for (let i = 0; i < 5; i++) {
                                const blockType = (i === 2) ? 'question' : 'brick';
                                const blockY = (i === 0 || i === 4) ? baseY : baseY - 40;
                                this.blocks.push({
                                    x: x + (i * 40),
                                    y: blockY,
                                    width: 40,
                                    height: 40,
                                    speed: 0,
                                    type: blockType,
                                    hit: false,
                                    bounceY: 0,
                                    bounceSpeed: 0
                                });
                            }
                            
                            // Moedas dentro do U
                            for (let i = 1; i < 4; i++) {
                                this.coins.push({
                                    x: x + (i * 40) + 10,
                                    y: baseY - 80,
                                    width: 25,
                                    height: 25,
                                    speed: 0,
                                    angle: 0,
                                    shine: Math.random() * 30
                                });
                            }
                        }
                        
                        // Inimigo voador ocasional
                        if (Math.random() < 0.3) {
                            this.obstacles.push({
                                x: x + 100,
                                y: baseY - 100,
                                width: 30,
                                height: 40,
                                speed: 2,
                                direction: Math.random() < 0.5 ? 1 : -1,
                                type: 'flying',
                                jumpVelocity: 0,
                                isJumping: false,
                                startY: baseY - 100,
                                frame: 0,
                                frameTime: 0,
                                behavior: this.getEnemyBehavior('flying')
                            });
                        }
                    }
                }
            }

            // Gerar área final do jogo - CASTELO E BANDEIRA MAIS À DIREITA
            generateEndArea() {
                // Mover o castelo e bandeira bem mais à direita - próximo ao final do mapa
                const endX = this.worldWidth - 250; // Bem mais próximo do final
                
                // Ajustar escada final com plataformas acessíveis
                for (let i = 0; i < 6; i++) {
                    for (let j = 0; j <= i; j++) {
                        this.blocks.push({
                            x: endX - 250 + (j * 40),
                            y: this.groundY - 40 - (i * 40),
                            width: 40,
                            height: 40,
                            speed: 0,
                            type: 'brick',
                            hit: false,
                            bounceY: 0,
                            bounceSpeed: 0
                        });
                    }
                }
                
                // Plataformas em escada reduzidas para acessar o castelo
                for (let i = 0; i < 3; i++) {
                    this.platforms.push({
                        x: endX - 50 + (i * 35),
                        y: this.groundY - 40 - (i * 40),
                        width: 60,
                        height: 20,
                        speed: 0
                    });
                    
                    // Moedas de bônus nas plataformas
                    const coinX = endX - 35 + (i * 35);
                    const coinY = this.groundY - 90 - (i * 40);
                    
                    if (this.isValidCoinPosition(coinX, coinY)) {
                        this.coins.push({
                            x: coinX,
                            y: coinY,
                            width: 25,
                            height: 25,
                            speed: 0,
                            angle: 0,
                            shine: Math.random() * 30
                        });
                    }
                }
                
                // Adicionar castelo em posição mais à direita
                this.castle = {
                    x: endX + 50, // Mais à direita
                    y: this.groundY - 130,
                    width: 180,
                    height: 130
                };
                
                // Adicionar bandeira mais próxima do castelo (à direita)
                this.flag = {
                    x: endX, // Posicionada antes do castelo
                    y: this.groundY - 190,
                    height: 190,
                    raised: false
                };
                
                // Garantir que não haja colisões ou obstáculos próximos ao final
                this.blocks = this.blocks.filter(block => 
                    block.x < endX - 300 || block.x > endX + 300
                );
                
                this.obstacles = this.obstacles.filter(obstacle => 
                    obstacle.x < endX - 300 || obstacle.x > endX + 300
                );
                this.blocks = this.blocks.filter(block => 
                    block.x < endX - 200 || block.x > endX + 500
                );
                
                this.obstacles = this.obstacles.filter(obstacle => 
                    obstacle.x < endX - 200 || obstacle.x > endX + 500
                );
                
                // Adicionar "boss" antes do castelo
                this.obstacles.push({
                    x: endX + 120,
                    y: this.groundY - 80,
                    width: 50,
                    height: 80,
                    speed: 2,
                    direction: -1,
                    type: 'boss',
                    health: 3,
                    jumpVelocity: 0,
                    isJumping: false,
                    startY: this.groundY - 80,
                    frame: 0,
                    frameTime: 0,
                    fireballTimer: 0,
                    behavior: this.getEnemyBehavior('goomba')
                });
                
                // Adicionar algumas moedas perto da bandeira
                for (let i = 0; i < 5; i++) {
                    this.coins.push({
                        x: endX - 50 + (i * 20),
                        y: this.groundY - 70 - (i * 20),
                        width: 25,
                        height: 25,
                        speed: 0,
                        angle: 0,
                        shine: Math.random() * 30
                    });
                }
            }

            // Método para corrigir áreas problemáticas específicas
            fixKnownLayoutIssues() {
                // Corrigir a área no início do jogo (mostrada na imagem)
                const problemAreas = [
                    {
                        startX: 0,
                        endX: 500,
                        fix: () => {
                            // Remover blocos problemáticos nesta área
                            this.blocks = this.blocks.filter(block => 
                                !(block.x >= 0 && block.x < 500 && 
                                  block.y < this.groundY - 60 && 
                                  this.isPotentialBlockage(block))
                            );
                            
                            // Remover plataformas mal posicionadas
                            this.platforms = this.platforms.filter(platform => 
                                !(platform.x >= 0 && platform.x < 500 && 
                                  platform.y < this.groundY - 70)
                            );
                            
                            // Adicionar layout corrigido
                            // Plataforma principal mais baixa e acessível
                            this.platforms.push({
                                x: 250,
                                y: this.groundY - 90,
                                width: 150,
                                height: 20,
                                speed: 0
                            });
                            
                            // Blocos de ? e tijolos em posições acessíveis
                            this.blocks.push({
                                x: 100,
                                y: this.groundY - 140,
                                width: 40,
                                height: 40,
                                speed: 0,
                                type: 'question',
                                hit: false,
                                broken: false,
                                bounceY: 0,
                                bounceSpeed: 0
                            });
                            
                            this.blocks.push({
                                x: 170,
                                y: this.groundY - 140,
                                width: 40,
                                height: 40,
                                speed: 0,
                                type: 'brick',
                                hit: false,
                                broken: false,
                                bounceY: 0,
                                bounceSpeed: 0
                            });
                            
                            // Tubo verde com altura apropriada
                            this.pipes = this.pipes.filter(pipe => 
                                !(pipe.x >= 300 && pipe.x < 400)
                            );
                            
                            this.pipes.push({
                                x: 350,
                                y: this.groundY - 80, // Altura mais razoável
                                width: 60,
                                height: 80,
                                speed: 0
                            });
                        }
                    }
                    // Adicionar outras áreas problemáticas aqui conforme necessário
                ];
                
                // Aplicar correções
                problemAreas.forEach(area => {
                    area.fix();
                });
            }

            // Método auxiliar para verificar se um bloco pode estar causando um bloqueio
            isPotentialBlockage(block) {
                // Verificar se este bloco tem outros blocos empilhados acima ou abaixo
                const adjacentBlocks = this.blocks.filter(b => 
                    b !== block && 
                    Math.abs(b.x - block.x) < block.width &&
                    Math.abs(b.y - block.y) < block.height * 1.5
                );
                
                // Se houver mais de 1 bloco adjacente, pode ser um bloqueio
                return adjacentBlocks.length > 1;
            }

            // Sistema de Grade para Posicionamento de Elementos
            implementGridSystem() {
                // Definir tamanho da grade (múltiplo do tamanho dos blocos)
                this.gridSize = 40;
                
                // Converter posições existentes para aderir à grade
                this.snapAllObjectsToGrid();
            }

            // Ajustar todos os objetos à grade
            snapAllObjectsToGrid() {
                // Ajustar blocos
                this.blocks.forEach(block => {
                    block.x = Math.round(block.x / this.gridSize) * this.gridSize;
                    block.y = Math.round(block.y / this.gridSize) * this.gridSize;
                });
                
                // Ajustar plataformas
                this.platforms.forEach(platform => {
                    platform.x = Math.round(platform.x / this.gridSize) * this.gridSize;
                    platform.y = Math.round(platform.y / this.gridSize) * this.gridSize;
                    // Garantir que largura seja múltiplo da grade
                    platform.width = Math.max(this.gridSize, Math.round(platform.width / this.gridSize) * this.gridSize);
                });
                
                // Ajustar tubos
                this.pipes.forEach(pipe => {
                    pipe.x = Math.round(pipe.x / this.gridSize) * this.gridSize;
                    pipe.y = Math.round(pipe.y / this.gridSize) * this.gridSize;
                });
            }

            // Validar sobreposição de elementos
            validateObjectPlacement() {
                // Criar mapa de ocupação da grade
                const occupiedCells = {};
                
                // Função para marcar células como ocupadas
                const markOccupied = (x, y, width, height, object) => {
                    const gridX = Math.floor(x / this.gridSize);
                    const gridY = Math.floor(y / this.gridSize);
                    const gridWidth = Math.ceil(width / this.gridSize);
                    const gridHeight = Math.ceil(height / this.gridSize);
                    
                    for (let i = 0; i < gridWidth; i++) {
                        for (let j = 0; j < gridHeight; j++) {
                            const key = `${gridX + i},${gridY + j}`;
                            if (occupiedCells[key]) {
                                // Célula já ocupada, ajustar posição
                                return false;
                            }
                            occupiedCells[key] = object;
                        }
                    }
                    return true;
                };
                
                // Validar e corrigir blocos
                this.blocks = this.blocks.filter(block => {
                    // Tentar posicionar na grade
                    if (markOccupied(block.x, block.y, block.width, block.height, block)) {
                        return true;
                    }
                    
                    // Tentar reposicionar em células próximas livres
                    for (let offsetX = -3; offsetX <= 3; offsetX++) {
                        for (let offsetY = -2; offsetY <= 2; offsetY++) {
                            const newX = block.x + offsetX * this.gridSize;
                            const newY = block.y + offsetY * this.gridSize;
                            
                            if (markOccupied(newX, newY, block.width, block.height, block)) {
                                block.x = newX;
                                block.y = newY;
                                return true;
                            }
                        }
                    }
                    
                    // Não foi possível reposicionar, remover bloco
                    return false;
                });
                
                // Aplicar mesmo processo para plataformas
                this.platforms = this.platforms.filter(platform => {
                    // Tentar posicionar na grade
                    if (markOccupied(platform.x, platform.y, platform.width, platform.height, platform)) {
                        return true;
                    }
                    
                    // Tentar reposicionar em células próximas livres
                    for (let offsetX = -2; offsetX <= 2; offsetX++) {
                        for (let offsetY = -1; offsetY <= 1; offsetY++) {
                            const newX = platform.x + offsetX * this.gridSize;
                            const newY = platform.y + offsetY * this.gridSize;
                            
                            if (markOccupied(newX, newY, platform.width, platform.height, platform)) {
                                platform.x = newX;
                                platform.y = newY;
                                return true;
                            }
                        }
                    }
                    
                    return false;
                });
                
                // Aplicar mesmo processo para tubos
                this.pipes = this.pipes.filter(pipe => {
                    // Tentar posicionar na grade
                    if (markOccupied(pipe.x, pipe.y, pipe.width, pipe.height, pipe)) {
                        return true;
                    }
                    
                    // Tentar reposicionar em células próximas livres
                    for (let offsetX = -2; offsetX <= 2; offsetX++) {
                        const newX = pipe.x + offsetX * this.gridSize;
                        
                        if (markOccupied(newX, pipe.y, pipe.width, pipe.height, pipe)) {
                            pipe.x = newX;
                            return true;
                        }
                    }
                    
                    return false;
                });
            }

            // CORRIGIDO: Detecção de colisão melhorada para funcionar com câmera
            checkBlockCollisions() {
                // Verificação de segurança
                if (!this.mario || !this.blocks) return;
                
                // Armazenar último bloco atingido para debugging
                this.lastHitBlock = null;
                
                // Criar uma caixa de colisão mais precisa para a cabeça do Mario
                const marioHeadHitbox = {
                    x: this.mario.x + this.mario.width * 0.2,
                    width: this.mario.width * 0.6,
                    y: this.mario.y,
                    height: 10
                };
                
                // Encontrar blocos visíveis na tela ou próximos a ela
                const visibleBlocks = this.blocks.filter(block => {
                    const blockRight = block.x + block.width;
                    const screenRight = this.cameraX + this.canvas.width;
                    return blockRight >= this.cameraX - 100 && block.x <= screenRight + 100;
                });
                
                // NOVO DEBUG mais preciso e detalhado
                const blocksOnScreen = this.blocks.filter(block => {
                    if (block.broken) return false; // Excluir blocos quebrados
                    const drawX = block.x - this.cameraX;
                    // Filtro mais rigoroso: bloco deve estar completamente ou majoritariamente visível
                    return drawX >= -20 && drawX + block.width <= this.canvas.width + 20;
                });

                if (this.frameCount % 60 === 0) { // Reduzir frequência para 1x por segundo
                    console.log(`Blocos na tela: ${blocksOnScreen.length}, 
                    Blocos na área de colisão: ${visibleBlocks.length}, 
                    Total: ${this.blocks.length}, 
                    Câmera: ${Math.floor(this.cameraX)}`);
                }
                
                // Verificar colisão com a cabeça
                if (this.mario.velocityY < 0) { // Mario está pulando para cima
                    for (let block of visibleBlocks) {
                        // Ignorar blocos já quebrados
                        if (block.broken) continue;
                        
                        // Verificar colisão mais precisa
                        if (marioHeadHitbox.x < block.x + block.width &&
                            marioHeadHitbox.x + marioHeadHitbox.width > block.x &&
                            marioHeadHitbox.y < block.y + block.height &&
                            marioHeadHitbox.y + marioHeadHitbox.height > block.y) {
                            
                            // COLISÃO DETECTADA!
                            console.log("Colisão com bloco:", block.type, "posição:", block.x, block.y, "Mario:", this.mario.x, this.mario.y);
                            this.lastHitBlock = block;
                            
                            // Reposicionar o Mario
                            this.mario.y = block.y + block.height;
                            this.mario.velocityY = 2;
                            
                            // Processar bloco atingido
                            this.processBlockHit(block);
                            
                            return;
                        }
                    }
                }
                
                // Verificar outras colisões (laterais e inferiores)
                for (let block of visibleBlocks) {
                    if (block.broken) continue;
                    
                    if (this.mario.x + this.mario.width > block.x &&
                        this.mario.x < block.x + block.width &&
                        this.mario.y + this.mario.height > block.y &&
                        this.mario.y < block.y + block.height) {
                        
                        // Colisão superior (caindo em cima do bloco)
                        if (this.mario.velocityY > 0 && 
                            this.mario.y + this.mario.height - this.mario.velocityY <= block.y + 10) {
                            this.mario.y = block.y - this.mario.height;
                            this.mario.velocityY = 0;
                            this.mario.onGround = true;
                            this.mario.isJumping = false;
                        }
                        // Colisão lateral direita
                        else if (this.mario.velocityX > 0) {
                            this.mario.x = block.x - this.mario.width;
                            this.mario.velocityX = 0;
                        }
                        // Colisão lateral esquerda
                        else if (this.mario.velocityX < 0) {
                            this.mario.x = block.x + block.width;
                            this.mario.velocityX = 0;
                        }
                    }
                }
            }

            // CORRIGIDO: Método para processar bloco quando atingido
            processBlockHit(block) {
                // Verificação de segurança
                if (!block) return;
                
                if (block.type === 'brick' && !block.hit && !block.broken) {
                    // Efeito visual de quicar
                    block.bounceY = block.y;
                    block.bounceSpeed = -6;
                    block.hit = true;
                    
                    // Criar efeito de partículas
                    this.createBlockParticles(block.x + block.width/2, block.y + block.height/2);
                    block.broken = true;
                    this.score += 50;
                    this.playSound(this.sounds.hit);
                    this.updateScoreDisplay();
                } 
                else if (block.type === 'question' && !block.hit) {
                    // Marcar como atingido
                    block.hit = true;
                    block.bounceY = block.y;
                    block.bounceSpeed = -6;
                    
                    // Criar moeda
                    this.spawnCoin(block.x + block.width/2 - 12, block.y - 40, true);
                    this.score += 100;
                    this.playSound(this.sounds.coin);
                    this.updateScoreDisplay();
                }
            }

            // NOVO MÉTODO: Verificar outras colisões com blocos (laterais/inferiores)
            checkOtherBlockCollisions(nearbyBlocks) {
                // Verificação de segurança
                if (!this.mario || !nearbyBlocks) return;
                
                // Verificar colisões laterais e inferiores
                for (let block of nearbyBlocks) {
                    // Ignorar blocos quebrados
                    if (block.broken) continue;
                    
                    // Verificar colisão completa (todo o corpo do Mario)
                    if (this.mario.x + this.mario.width > block.x &&
                        this.mario.x < block.x + block.width &&
                        this.mario.y + this.mario.height > block.y &&
                        this.mario.y < block.y + block.height) {
                        
                        // Determinar direção da colisão pela velocidade e posição
                        if (this.mario.velocityY > 0 && 
                            this.mario.y + this.mario.height - this.mario.velocityY <= block.y + 5) {
                            // Colisão inferior (Mario pousando em cima do bloco)
                            this.mario.y = block.y - this.mario.height;
                            this.mario.velocityY = 0;
                            this.mario.onGround = true;
                            this.mario.isJumping = false;
                        }
                        else if (this.mario.velocityX > 0) {
                            // Colisão pela esquerda
                            this.mario.x = block.x - this.mario.width;
                            this.mario.velocityX = 0;
                        }
                        else if (this.mario.velocityX < 0) {
                            // Colisão pela direita
                            this.mario.x = block.x + block.width;
                            this.mario.velocityX = 0;
                        }
                    }
                }
            }

            // Função para verificar se uma moeda não se sobrepõe a elementos do jogo
            isValidCoinPosition(x, y, width = 25, height = 25) {
                const coinRect = { x, y, width, height };
                
                // Verificar sobreposição com pipes
                for (const pipe of this.pipes) {
                    if (this.checkCollision(coinRect, pipe)) {
                        return false;
                    }
                }
                
                // Verificar sobreposição com blocos
                for (const block of this.blocks) {
                    if (this.checkCollision(coinRect, block)) {
                        return false;
                    }
                }
                
                // Verificar sobreposição com plataformas
                for (const platform of this.platforms) {
                    if (this.checkCollision(coinRect, platform)) {
                        return false;
                    }
                }
                
                return true;
            }

            // Método para criar partículas de bloco quebrado
            createBlockParticles(x, y, color = '#B25B00') {
                // Garantir que o array de partículas existe
                if (!this.particles) this.particles = [];
                
                // Adicionar 8 partículas em direções diferentes
                for (let i = 0; i < 8; i++) {
                    const angle = Math.PI * 2 * (i / 8);
                    const speed = 2 + Math.random() * 3;
                    
                    this.particles.push({
                        x: x,
                        y: y,
                        size: 5 + Math.random() * 5,
                        speedX: Math.cos(angle) * speed,
                        speedY: Math.sin(angle) * speed - 3, // Impulso para cima
                        opacity: 1,
                        color: color,
                        gravity: 0.2,
                        life: 60 + Math.random() * 20,
                        rotation: Math.random() * 360,
                        rotationSpeed: (Math.random() - 0.5) * 10
                    });
                }
            }

            // Sistema de debug removido - função desnecessária

            // Método para gerar blocos quebráveis
            generateBrickBlocks() {
                // Reduzir quantidade de blocos quebráveis
                const brickPositions = [
                    // Início do jogo
                    {x: 350, y: this.groundY - 180, count: 2}, // Reduzido de 3 para 2
                    {x: 900, y: this.groundY - 140, count: 2}, // Reduzido de 4 para 2
                    {x: 1400, y: this.groundY - 160, count: 1}, // Reduzido de 2 para 1
                    // Meio do jogo
                    {x: 3500, y: this.groundY - 170, count: 3}, // Reduzido de 5 para 3
                    {x: 4800, y: this.groundY - 140, count: 2}, // Reduzido de 3 para 2
                    // Fim do jogo
                    {x: 8100, y: this.groundY - 180, count: 2}, // Reduzido de 4 para 2
                    {x: 8900, y: this.groundY - 150, count: 2}, // Reduzido de 3 para 2
                    // Reduzir posições extras
                    {x: 2700, y: this.groundY - 160, count: 2}, // Reduzido de 3 para 2
                    {x: 6100, y: this.groundY - 180, count: 2}, // Reduzido de 4 para 2
                    {x: 7000, y: this.groundY - 150, count: 2}  // Reduzido de 5 para 2
                ];
                
                brickPositions.forEach(pos => {
                    for (let i = 0; i < pos.count; i++) {
                        this.blocks.push({
                            x: pos.x + (i * 60), // Aumentado de 45 para 60
                            y: pos.y,
                            width: 40,
                            height: 40,
                            speed: 0,
                            type: 'brick',
                            hit: false,
                            broken: false,
                            bounceY: 0,
                            bounceSpeed: 0
                        });
                    }
                });
            }

            // Método para verificar e corrigir blocos sobre plataformas
            fixBlocksOverPlatforms() {
                // Distância mínima entre plataformas e blocos
                const minVerticalGap = 60;
                
                // Verificar cada bloco
                this.blocks.forEach(block => {
                    // Verificar se há alguma plataforma diretamente sob o bloco
                    const platformUnder = this.platforms.find(platform => 
                        block.x + block.width > platform.x && 
                        block.x < platform.x + platform.width &&
                        Math.abs((block.y + block.height) - platform.y) < 10 // Quase tocando
                    );
                    
                    if (platformUnder) {
                        // Reposicionar o bloco para estar acima da plataforma com espaço adequado
                        block.y = platformUnder.y - block.height - minVerticalGap;
                    }
                    
                    // Verificar se há blocos empilhados em uma mesma coluna
                    const blocksInSameColumn = this.blocks.filter(b => 
                        b !== block && 
                        Math.abs(b.x - block.x) < block.width/2 &&
                        Math.abs(b.y - block.y) < block.height * 2
                    );
                    
                    // Se houver blocos empilhados, espaçá-los horizontalmente
                    if (blocksInSameColumn.length > 0) {
                        // Mover este bloco para o lado
                        block.x += block.width * 1.5;
                    }
                });
                
                // Espaçar horizontalmente os blocos acima das plataformas
                const platformTops = {};
                
                // Agrupar blocos por plataforma
                this.blocks.forEach(block => {
                    this.platforms.forEach(platform => {
                        if (block.x >= platform.x && block.x <= platform.x + platform.width) {
                            const key = `${platform.x}-${platform.y}`;
                            if (!platformTops[key]) platformTops[key] = [];
                            platformTops[key].push(block);
                        }
                    });
                });
                
                // Redistribuir blocos em cada plataforma
                Object.values(platformTops).forEach(blocks => {
                    if (blocks.length > 1) {
                        // Ordenar por posição X
                        blocks.sort((a, b) => a.x - b.x);
                        
                        // Espaçar uniformemente
                        const platform = this.platforms.find(p => 
                            blocks[0].x >= p.x && blocks[0].x <= p.x + p.width
                        );
                        
                        if (platform) {
                            const platformWidth = platform.width;
                            const spacing = platformWidth / (blocks.length + 1);
                            
                            blocks.forEach((block, index) => {
                                block.x = platform.x + spacing * (index + 1) - block.width/2;
                            });
                        }
                    }
                });
            }

            // Garantir que existam blocos até o final do jogo
            ensureBricksToEnd() {
                // Verificar se há blocos de tijolo no último terço do jogo
                const finalThirdStart = this.worldWidth * 2/3;
                const finalBricks = this.blocks.filter(block => 
                    block.x > finalThirdStart && block.type === 'brick'
                );
                
                // Se houver poucos blocos na parte final, adicionar mais
                if (finalBricks.length < 10) {
                    const numToAdd = 15; // Adicionar um bom número de blocos
                    const spacing = (this.worldWidth - finalThirdStart) / (numToAdd + 1);
                    
                    for (let i = 1; i <= numToAdd; i++) {
                        const x = finalThirdStart + (spacing * i);
                        const y = this.groundY - 100 - (Math.random() * 80);
                        
                        // Adicionar bloco de tijolo
                        this.blocks.push({
                            x: x,
                            y: y,
                            width: 40,
                            height: 40,
                            speed: 0,
                            type: Math.random() > 0.3 ? 'brick' : 'question', // 70% de chance de tijolo
                            hit: false,
                            broken: false,
                            bounceY: 0,
                            bounceSpeed: 0
                        });
                        
                        // Chance de adicionar moeda acima do bloco
                        if (Math.random() > 0.5) {
                            this.coins.push({
                                x: x + 7.5,
                                y: y - 40,
                                width: 25,
                                height: 25,
                                speed: 0,
                                angle: 0,
                                shine: Math.random() * 30
                            });
                        }
                    }
                }
                
                // Verificar se existem plataformas no último terço
                const finalPlatforms = this.platforms.filter(platform => 
                    platform.x > finalThirdStart
                );
                
                // Adicionar mais plataformas se necessário
                if (finalPlatforms.length < 5) {
                    const numPlatformsToAdd = 8;
                    const platformSpacing = (this.worldWidth - finalThirdStart) / (numPlatformsToAdd + 1);
                    
                    for (let i = 1; i <= numPlatformsToAdd; i++) {
                        const x = finalThirdStart + (platformSpacing * i);
                        const width = 80 + Math.random() * 60;
                        const y = this.groundY - 70 - (Math.random() * 60);
                        
                        this.platforms.push({
                            x: x - width/2,
                            y: y,
                            width: width,
                            height: 20,
                            speed: 0
                        });
                        
                        // Adicionar inimigo em algumas plataformas
                        if (Math.random() > 0.6) {
                            const enemyType = ['goomba', 'turtle'][Math.floor(Math.random() * 2)];
                            this.obstacles.push({
                                x: x,
                                y: y - 40,
                                width: 30,
                                height: 40,
                                speed: 1.5,
                                direction: Math.random() > 0.5 ? 1 : -1,
                                type: enemyType,
                                jumpVelocity: 0,
                                isJumping: false,
                                startY: y - 40,
                                frame: 0,
                                frameTime: 0,
                                behavior: this.getEnemyBehavior(enemyType)
                            });
                        }
                    }
                }
            }

            // Método para adicionar inimigos bem distribuídos
            addEvenlyDistributedEnemies() {
                // Garantir que haja um inimigo a cada X distância
                const enemyGap = 600; // Um inimigo a cada 600px no mínimo
                
                for (let x = 500; x < this.worldWidth - 1000; x += enemyGap) {
                    // Verificar se já existe um inimigo próximo
                    const hasNearbyEnemy = this.obstacles.some(enemy => 
                        Math.abs(enemy.x - x) < enemyGap/2
                    );
                    
                    if (!hasNearbyEnemy) {
                        // Tipo aleatório de inimigo
                        const enemyTypes = ['goomba', 'turtle', 'jumping', 'flying'];
                        const enemyType = enemyTypes[Math.floor(Math.random() * enemyTypes.length)];
                        
                        let yPos;
                        if (enemyType === 'flying') {
                            yPos = this.groundY - 120 - Math.random() * 60;
                        } else {
                            yPos = this.groundY - 40;
                        }
                        
                        this.obstacles.push({
                            x: x,
                            y: yPos,
                            width: 30,
                            height: 40,
                            speed: enemyType === 'turtle' ? 1 : 2,
                            direction: Math.random() > 0.5 ? 1 : -1,
                            type: enemyType,
                            jumpVelocity: enemyType === 'jumping' ? 0 : 0,
                            isJumping: false,
                            startY: yPos,
                            frame: 0,
                            frameTime: 0,
                            behavior: this.getEnemyBehavior(enemyType)
                        });
                    }
                }
            }

            // Método para preencher áreas vazias
            fillEmptyAreas() {
                // Identificar e preencher áreas vazias
                const segmentSize = 800; // Verificar cada segmento de 800px
                
                for (let x = 0; x < this.worldWidth; x += segmentSize) {
                    // Contar objetos neste segmento
                    const blocksInSegment = this.blocks.filter(block => 
                        block.x >= x && block.x < x + segmentSize
                    ).length;
                    
                    const platformsInSegment = this.platforms.filter(platform => 
                        platform.x >= x && platform.x < x + segmentSize
                    ).length;
                    
                    const pipesInSegment = this.pipes.filter(pipe => 
                        pipe.x >= x && pipe.x < x + segmentSize
                    ).length;
                    
                    const totalObjects = blocksInSegment + platformsInSegment + pipesInSegment;
                    
                    // Se o segmento tem poucos objetos, adicionar mais
                    if (totalObjects < 3) {
                        const numToAdd = 3 - totalObjects;
                        
                        for (let i = 0; i < numToAdd; i++) {
                            const objectType = Math.random();
                            const posX = x + Math.random() * segmentSize;
                            
                            if (objectType < 0.4) {
                                // Adicionar bloco
                                const blockType = Math.random() > 0.5 ? 'question' : 'brick';
                                this.blocks.push({
                                    x: posX,
                                    y: this.groundY - 140 - Math.random() * 80,
                                    width: 40,
                                    height: 40,
                                    speed: 0,
                                    type: blockType,
                                    hit: false,
                                    broken: false,
                                    bounceY: 0,
                                    bounceSpeed: 0
                                });
                            }
                            else if (objectType < 0.7) {
                                // Adicionar plataforma
                                const platformWidth = 80 + Math.random() * 120;
                                this.platforms.push({
                                    x: posX,
                                    y: this.groundY - 100 - Math.random() * 60,
                                    width: platformWidth,
                                    height: 20,
                                    speed: 0
                                });
                            }
                            else {
                                // Adicionar tubo
                                const tubeHeight = 60 + Math.random() * 80;
                                this.pipes.push({
                                    x: posX,
                                    y: this.groundY - tubeHeight,
                                    width: 60,
                                    height: tubeHeight,
                                    speed: 0
                                });
                            }
                        }
                    }
                }
            }

            // Método para validar caminho do jogo
            validateGameplayPath() {
                // Verificar se há gaps impossíveis de pular
                const maxJumpDistance = 200; // Distância máxima que Mario consegue pular
                
                // Ordenar todas as plataformas, blocos e tubos por posição X
                const allPlatforms = [
                    ...this.platforms.map(p => ({x: p.x, width: p.width, y: p.y})),
                    ...this.blocks.map(b => ({x: b.x, width: b.width, y: b.y})),
                    ...this.pipes.map(p => ({x: p.x, width: p.width, y: p.y}))
                ].sort((a, b) => a.x - b.x);
                
                // Verificar gaps
                for (let i = 0; i < allPlatforms.length - 1; i++) {
                    const current = allPlatforms[i];
                    const next = allPlatforms[i + 1];
                    const gap = next.x - (current.x + current.width);
                    
                    // Se o gap for muito grande e não há chão comum
                    if (gap > maxJumpDistance) {
                        // Adicionar plataforma intermediária
                        const midX = current.x + current.width + gap / 2 - 40;
                        const platformHeight = Math.min(current.y, next.y) + Math.random() * 40;
                        
                        this.platforms.push({
                            x: midX,
                            y: platformHeight,
                            width: 80,
                            height: 20,
                            speed: 0
                        });
                        
                        // Adicionar moedas para guiar o jogador - verificar posicionamento
                        for (let j = 0; j < 3; j++) {
                            const coinX = midX - 50 + (j * 40);
                            const coinY = platformHeight - 60; // Mais acima da plataforma
                            
                            if (this.isValidCoinPosition(coinX, coinY)) {
                                this.coins.push({
                                    x: coinX,
                                    y: coinY,
                                    width: 25,
                                    height: 25,
                                    speed: 0,
                                    angle: 0,
                                    shine: Math.random() * 30
                                });
                            }
                        }
                    }
                }
            }

            // Verificação global de jogabilidade
            validateAllGameplayAreas() {
                // Dividir o mundo em seções e verificar cada uma
                const sectionSize = 300;
                const numSections = Math.ceil(this.worldWidth / sectionSize);
                
                for (let i = 0; i < numSections; i++) {
                    const startX = i * sectionSize;
                    const endX = startX + sectionSize;
                    
                    // 1. Verificar bloqueios verticais
                    this.checkVerticalBlockages(startX, endX);
                    
                    // 2. Verificar layouts impossíveis
                    this.checkImpossibleJumps(startX, endX);
                    
                    // 3. Verificar densidade de objetos
                    this.ensurePathExists(startX, endX);
                }
            }

            // Verificar bloqueios verticais causados por blocos empilhados
            checkVerticalBlockages(startX, endX) {
                // Agrupar blocos por posição X aproximada
                const blocksByColumn = {};
                
                this.blocks.forEach(block => {
                    if (block.x >= startX && block.x < endX) {
                        const column = Math.floor(block.x / 40);
                        if (!blocksByColumn[column]) {
                            blocksByColumn[column] = [];
                        }
                        blocksByColumn[column].push(block);
                    }
                });
                
                // Verificar colunas com muitos blocos empilhados (mais de 3)
                Object.values(blocksByColumn).forEach(columnBlocks => {
                    if (columnBlocks.length > 3) {
                        // Ordenar blocos por altura (y)
                        columnBlocks.sort((a, b) => a.y - b.y);
                        
                        // Remover alguns blocos do meio para criar passagem
                        for (let i = 1; i < columnBlocks.length - 1; i += 2) {
                            columnBlocks[i].broken = true;
                        }
                    }
                });
                
                // Remoção de blocos quebrados será feita pela função updateBlocks()
            }

            // Verificar e corrigir saltos impossíveis
            checkImpossibleJumps(startX, endX) {
                const maxJumpDistance = 180;
                const maxJumpHeight = 120;
                
                // Encontrar todos os elementos "pisáveis" nesta seção
                const platforms = [
                    ...this.platforms.filter(p => p.x >= startX && p.x < endX),
                    ...this.blocks.filter(b => b.x >= startX && b.x < endX),
                    ...this.pipes.filter(p => p.x >= startX && p.x < endX)
                ];
                
                // Ordenar por posição X
                platforms.sort((a, b) => a.x - b.x);
                
                // Verificar gaps verticais e horizontais
                for (let i = 0; i < platforms.length - 1; i++) {
                    const current = platforms[i];
                    const next = platforms[i + 1];
                    
                    const horizontalGap = next.x - (current.x + current.width);
                    const verticalDiff = Math.abs(current.y - next.y);
                    
                    // Se o gap for muito grande horizontalmente e verticalmente
                    if (horizontalGap > maxJumpDistance && verticalDiff > maxJumpHeight) {
                        // Adicionar plataforma intermediária
                        this.platforms.push({
                            x: current.x + current.width + horizontalGap/2 - 40,
                            y: (current.y + next.y) / 2,
                            width: 80,
                            height: 20,
                            speed: 0
                        });
                    }
                }
            }

            // Garantir que sempre exista um caminho
            ensurePathExists(startX, endX) {
                // Verificar se há pelo menos um caminho válido através desta seção
                const platformsInSection = this.platforms.filter(p => 
                    (p.x >= startX && p.x < endX) || 
                    (p.x + p.width >= startX && p.x + p.width < endX)
                ).length;
                
                const blocksInSection = this.blocks.filter(b => 
                    b.x >= startX && b.x < endX
                ).length;
                
                const pipesInSection = this.pipes.filter(p => 
                    p.x >= startX && p.x < endX
                ).length;
                
                // Se houver poucos elementos ou muitos empilhados
                if (platformsInSection + blocksInSection + pipesInSection < 2 || 
                    blocksInSection > 10) {
                    
                    // Reset desta seção com layout simples e garantido
                    this.resetSectionLayout(startX, endX);
                }
            }

            // Resetar layout de uma seção problemática
            resetSectionLayout(startX, endX) {
                // Remover elementos existentes nesta seção
                this.blocks = this.blocks.filter(b => !(b.x >= startX && b.x < endX));
                this.platforms = this.platforms.filter(p => !(p.x >= startX && p.x < endX));
                this.pipes = this.pipes.filter(p => !(p.x >= startX && p.x < endX));
                
                // Adicionar layout simples e garantidamente jogável
                // Plataforma central
                this.platforms.push({
                    x: startX + (endX - startX) / 2 - 75,
                    y: this.groundY - 80,
                    width: 150,
                    height: 20,
                    speed: 0
                });
                
                // Alguns blocos espalhados
                for (let i = 0; i < 3; i++) {
                    this.blocks.push({
                        x: startX + 50 + (i * 70),
                        y: this.groundY - 150,
                        width: 40,
                        height: 40,
                        speed: 0,
                        type: i === 1 ? 'question' : 'brick',
                        hit: false,
                        broken: false,
                        bounceY: 0,
                        bounceSpeed: 0
                    });
                }
                
                // Um tubo
                this.pipes.push({
                    x: startX + (endX - startX) * 0.7,
                    y: this.groundY - 70,
                    width: 60,
                    height: 70,
                    speed: 0
                });
            }

            // Método para otimizar plataformas e evitar sobreposições
            optimizePlatforms() {
                // Primeiro, remover plataformas que se sobrepõem com outros elementos
                const elementsToCheck = [...this.pipes, ...this.blocks];
                const margin = 15; // Margem de segurança
                
                this.platforms = this.platforms.filter(platform => {
                    // Verificar se a plataforma colide com algum elemento
                    const hasCollision = elementsToCheck.some(element => 
                        platform.x < element.x + element.width + margin &&
                        platform.x + platform.width + margin > element.x &&
                        platform.y < element.y + element.height + margin &&
                        platform.y + platform.height + margin > element.y
                    );
                    
                    return !hasCollision; // Manter apenas plataformas sem colisão
                });
                
                // Reduzir quantidade se ainda houver muitas plataformas
                if (this.platforms.length > 20) {
                    this.platforms.sort((a, b) => a.x - b.x);
                    
                    const platformsToKeep = [];
                    for (let i = 0; i < this.platforms.length; i += 2) {
                        platformsToKeep.push(this.platforms[i]);
                    }
                    
                    this.platforms = platformsToKeep;
                }
                
                // Ajustar posições das plataformas restantes
                this.platforms.forEach(platform => {
                    const minHeight = this.groundY - 200;
                    const maxHeight = this.groundY - 80;
                    
                    if (platform.y < minHeight || platform.y > maxHeight) {
                        platform.y = minHeight + Math.floor((platform.x * 631) % (maxHeight - minHeight));
                    }
                });
                
                console.log(`Otimizadas plataformas: ${this.platforms.length} restantes`);
            }

            // Método para corrigir posicionamento de canos no chão
            fixPipesPositioning() {
                // Corrigir todos os canos existentes para garantir que toquem o chão
                this.pipes.forEach(pipe => {
                    pipe.y = this.groundY - pipe.height;
                });
                
                console.log(`Corrigidos ${this.pipes.length} canos para tocarem o chão`);
            }

            // Método para posicionar a câmera
            updateCamera() {
                // Sistema de câmera mais fluido e sem paredes invisíveis
                const targetCameraX = this.mario.x - this.canvas.width / 3; // Mario no terço esquerdo da tela
                
                // Suavizar movimento da câmera (interpolação mais suave)
                this.cameraX = this.cameraX + (targetCameraX - this.cameraX) * 0.08;
                
                // Ajustar limites da câmera para o mapa reduzido (5400px)
                // Permitir ver um pouco além do fim para o castelo
                const maxCamera = this.worldWidth - this.canvas.width + 100; 
                this.cameraX = Math.max(0, Math.min(this.cameraX, maxCamera));
                
                // Correção adicional: remover limitação de Mario ficar "preso" nas bordas
                // Remover a limitação que impedia Mario de se mover livremente
            }

            // Método para definir comportamento dos inimigos
            getEnemyBehavior(type) {
                const self = this;
                switch (type) {
                    case 'goomba':
                        return function(enemy, mario) {
                            // Sistema anti-travamento aprimorado especialmente para canos
                            if (enemy.stuckCounter === undefined) enemy.stuckCounter = 0;
                            if (enemy.lastX === undefined) enemy.lastX = enemy.x;
                            
                            const stuckThreshold = 30; // Reduzido de 45 para 30
                            const movementThreshold = 0.5; // Mais sensível
                            
                            // Detectar travamento com mais precisão
                            if (Math.abs(enemy.x - enemy.lastX) < movementThreshold) {
                                enemy.stuckCounter += 2; // Incremento mais rápido
                            } else {
                                enemy.stuckCounter = 0;
                            }
                            
                            // Sistema de destravamento melhorado
                            if (enemy.stuckCounter > stuckThreshold) {
                                enemy.direction *= -1; // Mudar direção
                                enemy.x += enemy.direction * 15; // Empurrão maior para garantir escape
                                enemy.stuckCounter = 0;
                            }
                            
                            enemy.lastX = enemy.x;
                            
                            // Adicionar verificação prévia de colisão ANTES do movimento
                            const nextX = enemy.x + (enemy.speed * enemy.direction);
                            const willCollide = [...self.pipes, ...self.blocks].some(obj => 
                                nextX + enemy.width > obj.x &&
                                nextX < obj.x + obj.width &&
                                enemy.y + enemy.height > obj.y &&
                                enemy.y < obj.y + obj.height
                            );
                            
                            // Se vai colidir, mudar direção ANTES do movimento
                            if (willCollide) {
                                enemy.direction *= -1;
                                enemy.x += enemy.direction * 10; // Empurrão preventivo
                            } else {
                                // Movimento normal apenas se não vai colidir
                                enemy.x += enemy.speed * enemy.direction;
                            }
                            
                            // Verificar limites do mundo com margem
                            if (enemy.x <= 10 || enemy.x >= self.worldWidth - 50) {
                                enemy.direction *= -1;
                                enemy.x = Math.max(10, Math.min(enemy.x, self.worldWidth - 50));
                            }
                            
                            // Verificar colisão com tubos e blocos
                            const collisionObj = [...self.pipes, ...self.blocks].find(obj => 
                                enemy.x + enemy.width > obj.x &&
                                enemy.x < obj.x + obj.width &&
                                enemy.y + enemy.height > obj.y &&
                                enemy.y < obj.y + obj.height
                            );
                            
                            if (collisionObj) {
                                enemy.direction *= -1; // Mudar direção
                                // Empurrar para fora da colisão
                                if (enemy.direction > 0) {
                                    enemy.x = collisionObj.x - enemy.width - 5;
                                } else {
                                    enemy.x = collisionObj.x + collisionObj.width + 5;
                                }
                            }
                            
                            // Verificar se está prestes a cair de uma plataforma (melhorado)
                            const groundAhead = self.groundY;
                            const checkDistance = 50;
                            const platformCheckX = enemy.x + enemy.direction * checkDistance;
                            
                            const platformAhead = self.platforms.find(p => 
                                platformCheckX + enemy.width > p.x &&
                                platformCheckX < p.x + p.width &&
                                Math.abs(p.y - (enemy.y + enemy.height)) < 10
                            );
                            
                            if (!platformAhead && enemy.y + enemy.height < groundAhead - 20) {
                                enemy.direction *= -1; // Mudar direção se for cair
                            }
                            
                            // Aplicar gravidade básica
                            if (enemy.y + enemy.height < self.groundY) {
                                enemy.y += 2; // Gravidade simples
                            } else {
                                enemy.y = self.groundY - enemy.height;
                            }
                        };
                        
                    case 'turtle':
                        return function(enemy, mario) {
                            // Sistema anti-travamento para tartarugas
                            if (enemy.stuckCounter === undefined) enemy.stuckCounter = 0;
                            if (enemy.lastX === undefined) enemy.lastX = enemy.x;
                            if (enemy.patrolStart === undefined) enemy.patrolStart = enemy.x;
                            
                            // Detecção de travamento
                            if (Math.abs(enemy.x - enemy.lastX) < 0.5) {
                                enemy.stuckCounter++;
                                if (enemy.stuckCounter > 60) { // 1 segundo
                                    enemy.direction *= -1;
                                    enemy.x += enemy.direction * 10;
                                    enemy.stuckCounter = 0;
                                    enemy.patrolStart = enemy.x; // Reset patrol area
                                }
                            } else {
                                enemy.stuckCounter = 0;
                            }
                            
                            enemy.lastX = enemy.x;
                            
                            // Tartarugas são mais lentas mas resilientes
                            enemy.x += enemy.speed * enemy.direction;
                            
                            // Patrulhar numa área reduzida (ajustado para mapa menor)
                            const patrolRange = 150;
                            if (Math.abs(enemy.x - enemy.patrolStart) > patrolRange) {
                                enemy.direction *= -1;
                            }
                            
                            // Verificar limites do mundo
                            if (enemy.x <= 0 || enemy.x >= self.worldWidth - 40) {
                                enemy.direction *= -1;
                                enemy.patrolStart = enemy.x;
                            }
                            
                            // Mesma lógica de colisão do Goomba
                            const collisionObj = [...self.pipes, ...self.blocks].find(obj => 
                                enemy.x + enemy.width > obj.x &&
                                enemy.x < obj.x + obj.width &&
                                enemy.y + enemy.height > obj.y &&
                                enemy.y < obj.y + obj.height
                            );
                            
                            if (collisionObj) {
                                enemy.direction *= -1;
                                enemy.patrolStart = enemy.x; // Reset patrol area
                            }
                            
                            // Aplicar gravidade
                            if (enemy.y + enemy.height < self.groundY) {
                                enemy.y += 1.5;
                            } else {
                                enemy.y = self.groundY - enemy.height;
                            }
                        };
                        
                    case 'flying':
                        return function(enemy, mario) {
                            // Sistema anti-travamento para inimigos voadores
                            if (enemy.stuckCounter === undefined) enemy.stuckCounter = 0;
                            if (enemy.lastX === undefined) enemy.lastX = enemy.x;
                            if (enemy.startY === undefined) enemy.startY = enemy.y;
                            
                            // Detectar travamento horizontal
                            if (Math.abs(enemy.x - enemy.lastX) < 0.5) {
                                enemy.stuckCounter++;
                                if (enemy.stuckCounter > 30) {
                                    enemy.direction *= -1;
                                    enemy.x += enemy.direction * 15;
                                    enemy.stuckCounter = 0;
                                }
                            } else {
                                enemy.stuckCounter = 0;
                            }
                            
                            enemy.lastX = enemy.x;
                            
                            // Movimento sinusoidal melhorado
                            enemy.x += enemy.speed * enemy.direction;
                            
                            // Movimento vertical suave usando seno
                            const heightVariation = 30;
                            const period = 120; // em pixels
                            enemy.y = enemy.startY + Math.sin((enemy.x / period) * Math.PI * 2) * heightVariation;
                            
                            // Verificar limites do mundo
                            if (enemy.x <= 0 || enemy.x >= self.worldWidth - 40) {
                                enemy.direction *= -1;
                            }
                            
                            // Mudar direção ocasionalmente
                            if (Math.random() < 0.008) {
                                enemy.direction *= -1;
                            }
                            
                            // Limitar altura de voo (ajustado para mapa menor)
                            enemy.startY = Math.max(self.groundY - 180, Math.min(enemy.startY, self.groundY - 80));
                        };
                        
                    case 'jumping':
                        return function(enemy, mario) {
                            // Sistema anti-travamento para inimigos saltadores
                            if (enemy.stuckCounter === undefined) enemy.stuckCounter = 0;
                            if (enemy.lastX === undefined) enemy.lastX = enemy.x;
                            if (enemy.jumpVelocity === undefined) enemy.jumpVelocity = 0;
                            if (enemy.isJumping === undefined) enemy.isJumping = false;
                            if (enemy.onGround === undefined) enemy.onGround = true;
                            
                            // Detectar travamento
                            if (Math.abs(enemy.x - enemy.lastX) < 0.5) {
                                enemy.stuckCounter++;
                                if (enemy.stuckCounter > 40) {
                                    enemy.direction *= -1;
                                    enemy.jumpVelocity = -10; // Forçar pulo para destravamento
                                    enemy.isJumping = true;
                                    enemy.onGround = false;
                                    enemy.stuckCounter = 0;
                                }
                            } else {
                                enemy.stuckCounter = 0;
                            }
                            
                            enemy.lastX = enemy.x;
                            
                            // Movimento horizontal
                            enemy.x += enemy.speed * enemy.direction;
                            
                            // Verificar limites do mundo
                            if (enemy.x <= 0 || enemy.x >= self.worldWidth - 40) {
                                enemy.direction *= -1;
                            }
                            
                            // Controle de pulo melhorado
                            if (enemy.onGround) {
                                if (!enemy.jumpTimer) {
                                    enemy.jumpTimer = 30 + Math.floor(((enemy.x * 577) % 997) / 997 * 60);
                                }
                                
                                enemy.jumpTimer--;
                                
                                if (enemy.jumpTimer <= 0) {
                                    // Pular
                                    enemy.jumpVelocity = -10;
                                    enemy.onGround = false;
                                    enemy.isJumping = true;
                                    enemy.jumpTimer = null;
                                }
                            } else {
                                // Em pleno ar - aplicar gravidade
                                enemy.jumpVelocity += 0.5;
                            }
                            
                            // Aplicar movimento vertical
                            enemy.y += enemy.jumpVelocity;
                            
                            // Verificar colisão com o chão
                            if (enemy.y + enemy.height >= self.groundY) {
                                enemy.y = self.groundY - enemy.height;
                                enemy.onGround = true;
                                enemy.isJumping = false;
                                enemy.jumpVelocity = 0;
                                
                                // Mudar direção às vezes após pousar
                                if (Math.random() < 0.3) {
                                    enemy.direction *= -1;
                                }
                            }
                            
                            // Verificar plataformas
                            self.platforms.forEach(platform => {
                                if (enemy.jumpVelocity > 0 && // Caindo
                                    enemy.x + enemy.width > platform.x &&
                                    enemy.x < platform.x + platform.width &&
                                    enemy.y + enemy.height > platform.y - 5 &&
                                    enemy.y + enemy.height < platform.y + 10) {
                                    
                                    enemy.y = platform.y - enemy.height;
                                    enemy.onGround = true;
                                    enemy.isJumping = false;
                                    enemy.jumpVelocity = 0;
                                }
                            });
                            
                            // Verificar colisão com objetos e mudar direção
                            const collisionObj = [...self.pipes, ...self.blocks].find(obj => 
                                enemy.x + enemy.width > obj.x &&
                                enemy.x < obj.x + obj.width &&
                                enemy.y + enemy.height > obj.y &&
                                enemy.y < obj.y + obj.height
                            );
                            
                            if (collisionObj) {
                                enemy.direction *= -1;
                            }
                        };
                }
            }

            // Métodos auxiliares para efeitos e utilitários
            spawnParticles(x, y, color, count) {
                if (!this.particles) this.particles = [];
                
                for (let i = 0; i < count; i++) {
                    this.particles.push({
                        x: x + (Math.random() - 0.5) * 20,
                        y: y + (Math.random() - 0.5) * 20,
                        vx: (Math.random() - 0.5) * 6,
                        vy: (Math.random() - 0.5) * 6 - 2,
                        color: color,
                        life: 30 + Math.random() * 30,
                        maxLife: 30 + Math.random() * 30
                    });
                }
            }

            // Adicionar método para efeitos quando um inimigo é derrotado
            createEnemyDefeatedEffect(x, y) {
                // Efeito de pontuação
                this.scoreEffects = this.scoreEffects || [];
                this.scoreEffects.push({
                    x: x,
                    y: y,
                    text: "+200",
                    timer: 30
                });
                
                // Efeito de partículas melhorado
                for (let i = 0; i < 8; i++) {
                    const angle = Math.PI * 2 * (i / 8);
                    const speed = 2 + Math.random() * 2;
                    
                    this.particles.push({
                        x: x + 15,
                        y: y + 20,
                        size: 4 + Math.random() * 4,
                        speedX: Math.cos(angle) * speed,
                        speedY: Math.sin(angle) * speed - 2,
                        opacity: 1,
                        color: '#FF8C00',
                        gravity: 0.2,
                        life: 40 + Math.random() * 20
                    });
                }
            }

            // Método para desenhar efeitos de pontuação
            drawScoreEffects() {
                if (!this.scoreEffects) return;
                
                this.scoreEffects.forEach((effect, index) => {
                    this.ctx.save();
                    this.ctx.fillStyle = '#FFFFFF';
                    this.ctx.font = 'bold 16px Arial';
                    this.ctx.textAlign = 'center';
                    this.ctx.globalAlpha = effect.timer / 30;
                    
                    // Desenhar texto de pontuação
                    this.ctx.fillText(effect.text, effect.x - this.cameraX, effect.y);
                    
                    // Atualizar efeito
                    effect.y -= 1;
                    effect.timer--;
                    
                    // Remover efeito quando o timer acaba
                    if (effect.timer <= 0) {
                        this.scoreEffects.splice(index, 1);
                    }
                    
                    this.ctx.restore();
                });
            }

            takeDamage() {
                if (this.mario.invulnerable > 0) return;
                
                this.lives--;
                this.mario.invulnerable = 120; // 2 segundos de invulnerabilidade
                this.spawnParticles(this.mario.x + this.mario.width/2, this.mario.y + this.mario.height/2, '#FF0000', 6);
                
                if (this.lives <= 0) {
                    this.gameOver();
                } else {
                    // Pequeno knockback
                    this.mario.velocityY = -8;
                    this.mario.velocityX = this.mario.direction * -3;
                    this.playSound(this.sounds.hit);
                }
            }

            playSound(soundFunc) {
                if (soundFunc && typeof soundFunc === 'function') {
                    try {
                        soundFunc();
                    } catch (e) {
                        console.log('Erro ao reproduzir som:', e);
                    }
                }
            }

            // Sistema de água removido - método não necessário

            // Verificar final do jogo
            checkEndGame() {
                // Verificar se Mario alcançou a bandeira
                if (this.flag && !this.flag.raised &&
                    this.mario.x + this.mario.width > this.flag.x && 
                    this.mario.x < this.flag.x + 40) {
                    
                    this.flag.raised = true;
                    this.gameWon = true;
                    
                    // Tocar música de vitória
                    this.playSound(this.sounds.coin);
                    
                    // Animar Mario
                    this.mario.animation = 'victory';
                    this.mario.velocityX = 0;
                    
                    // Adicionar pontuação bônus
                    this.score += 1000;
                    
                    // Mostrar mensagem de vitória após um delay
                    setTimeout(() => {
                        this.ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                        this.ctx.fillRect(this.canvas.width/4, this.canvas.height/3, this.canvas.width/2, this.canvas.height/3);
                        
                        this.ctx.fillStyle = '#FFFFFF';
                        this.ctx.font = '24px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText('Você Venceu!', this.canvas.width/2, this.canvas.height/2 - 20);
                        this.ctx.fillText('Pontuação: ' + this.score, this.canvas.width/2, this.canvas.height/2 + 20);
                        
                        // Opção para reiniciar
                        this.ctx.font = '18px Arial';
                        this.ctx.fillText('Pressione ESPAÇO para jogar novamente', this.canvas.width/2, this.canvas.height/2 + 60);
                        
                        this.gameRunning = false;
                    }, 2000);
                }
            }

            setupControls() {
                // Touch controls
                const leftBtn = document.getElementById('leftBtn');
                const rightBtn = document.getElementById('rightBtn');
                const jumpBtn = document.getElementById('jumpBtn');
                const restartBtn = document.getElementById('restartBtn');
                const pauseBtn = document.getElementById('pauseBtn');
                const resumeBtn = document.getElementById('resumeBtn');

                // Prevent context menu on long press
                [leftBtn, rightBtn, jumpBtn].forEach(btn => {
                    btn.addEventListener('contextmenu', (e) => e.preventDefault());
                });

                leftBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.keys.left = true;
                });
                leftBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.keys.left = false;
                });

                rightBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.keys.right = true;
                });
                rightBtn.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    this.keys.right = false;
                });

                jumpBtn.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    this.jump();
                });
                
                pauseBtn.addEventListener('click', () => {
                    this.pauseGame();
                });
                
                resumeBtn.addEventListener('click', () => {
                    this.pauseGame(); // Toggle pause off
                });

                // Keyboard controls for desktop
                window.addEventListener('keydown', (e) => {
                    if (e.code === 'Escape' || e.code === 'KeyP') {
                        this.pauseGame();
                        return;
                    }
                    
                    if (this.gamePaused) return;
                    
                    switch(e.code) {
                        case 'ArrowLeft':
                        case 'KeyA':
                            this.keys.left = true;
                            break;
                        case 'ArrowRight':
                        case 'KeyD':
                            this.keys.right = true;
                            break;
                        case 'Space':
                        case 'ArrowUp':
                        case 'KeyW':
                            e.preventDefault();
                            this.keys.up = true;
                            this.jump();
                            break;
                    }
                });

                window.addEventListener('keyup', (e) => {
                    switch(e.code) {
                        case 'ArrowLeft':
                        case 'KeyA':
                            this.keys.left = false;
                            break;
                        case 'ArrowRight':
                        case 'KeyD':
                            this.keys.right = false;
                            break;
                        case 'Space':
                        case 'ArrowUp':
                        case 'KeyW':
                            this.keys.up = false;
                            break;
                            break;
                    }
                });

                restartBtn.addEventListener('click', () => this.startGame());
            }

            jump() {
                if (this.mario.onGround && this.gameRunning && !this.gamePaused) {
                    this.mario.velocityY = -12; // Velocidade inicial menor
                    this.mario.isJumping = true;
                    this.mario.onGround = false;
                    this.mario.jumpHoldTime = 300; // 300ms de tempo máximo de segurar pulo
                    this.sounds.jump();
                    
                    // Adicionar partículas de poeira ao pular
                    this.createJumpParticles();
                }
            }
            
            createJumpParticles() {
                for (let i = 0; i < 10; i++) {
                    this.particles.push({
                        x: this.mario.x + this.mario.width / 2,
                        y: this.mario.y + this.mario.height,
                        size: Math.random() * 5 + 3,
                        speedX: (Math.random() - 0.5) * 5,
                        speedY: Math.random() * -6,
                        opacity: 1,
                        color: '#E0E0E0'
                    });
                }
            }
            
            createCoinParticles(x, y) {
                for (let i = 0; i < 15; i++) {
                    this.particles.push({
                        x: x,
                        y: y,
                        size: Math.random() * 4 + 2,
                        speedX: (Math.random() - 0.5) * 8,
                        speedY: (Math.random() - 0.5) * 8,
                        opacity: 1,
                        color: '#FFD700'
                    });
                }
            }
            
            createHitParticles(x, y) {
                for (let i = 0; i < 20; i++) {
                    this.particles.push({
                        x: x + this.mario.width/2,
                        y: y + this.mario.height/2,
                        size: Math.random() * 6 + 4,
                        speedX: (Math.random() - 0.5) * 10,
                        speedY: (Math.random() - 0.5) * 10,
                        opacity: 1,
                        color: '#FF6B6B'
                    });
                }
            }

            // Função removida - spawn dinâmico desabilitado

            spawnCoin(x, y, animated = false) {
                if (animated) {
                    // Para moedas que saem dos blocos
                    if (!this.animatedCoins) this.animatedCoins = [];
                    this.animatedCoins.push({
                        x: x,
                        y: y,
                        velocityY: -8,
                        life: 60
                    });
                } else {
                    // Para moedas coletadas (efeito visual)
                    this.spawnParticles(x, y, '#FFD700', 4);
                }
            }

            // Função removida - spawn dinâmico desabilitado

            spawnPlatform() {
                // Verificar se já existem plataformas recentes
                const minPlatformDistance = 350;
                if (this.canvas.width - this.elementSpawnMap.lastPlatformX < minPlatformDistance) {
                    return; // Não spawnar outra plataforma ainda
                }
                
                // Escolher altura com verificação de sobreposição
                let platformHeight;
                let attempts = 0;
                do {
                    platformHeight = this.groundY - 100 - Math.random() * 120;
                    attempts++;
                    if (attempts > 5) break;
                } while (this.elementSpawnMap.occupiedHeights[Math.floor(platformHeight/20)]);
                
                // Marcar altura como ocupada
                const heightKey = Math.floor(platformHeight/20);
                this.elementSpawnMap.occupiedHeights[heightKey] = true;
                setTimeout(() => {
                    delete this.elementSpawnMap.occupiedHeights[heightKey];
                }, 4000);
                
                const platformWidth = 80 + Math.random() * 120;
                
                // Atualizar posição da última plataforma
                this.elementSpawnMap.lastPlatformX = this.canvas.width;
                
                this.platforms.push({
                    x: this.canvas.width,
                    y: platformHeight,
                    width: platformWidth,
                    height: 20,
                    speed: 4
                });
                
                // Adicionar itens na plataforma (com menos frequência)
                if (Math.random() < 0.3) { // 30% chance apenas
                    if (Math.random() < 0.5) { // 15% chance total para um bloco
                        this.blocks.push({
                            x: this.canvas.width + platformWidth/2 - 20,
                            y: platformHeight - 50,
                            width: 40,
                            height: 40,
                            speed: 4,
                            type: 'question',
                            hit: false,
                            bounceY: 0,
                            bounceSpeed: 0
                        });
                    } else { // 15% chance total para uma moeda
                        this.coins.push({
                            x: this.canvas.width + platformWidth/2 - 12,
                            y: platformHeight - 40,
                            width: 25,
                            height: 25,
                            speed: 4,
                            angle: 0,
                            shine: Math.random() * 30
                        });
                    }
                }
            }

            spawnPipe() {
                // Verificar se já existem canos recentes
                const minPipeDistance = 500;
                if (this.canvas.width - this.elementSpawnMap.lastPipeX < minPipeDistance) {
                    return; // Não spawnar outro cano ainda
                }
                
                // Variar mais a altura dos canos
                let pipeHeight;
                const heightType = Math.random();
                if (heightType < 0.4) {
                    pipeHeight = 60 + Math.random() * 30; // 40% canos baixos
                } else if (heightType < 0.8) {
                    pipeHeight = 100 + Math.random() * 30; // 40% canos médios
                } else {
                    pipeHeight = 140 + Math.random() * 40; // 20% canos altos
                }
                
                // Atualizar posição do último cano
                this.elementSpawnMap.lastPipeX = this.canvas.width;
                
                this.pipes.push({
                    x: this.canvas.width,
                    y: this.groundY - pipeHeight,
                    width: 60,
                    height: pipeHeight,
                    speed: 4
                });
                
                // Menos chance de colocar inimigo no cano (5% em vez de 10%)
                if (Math.random() < 0.05) {
                    const obstacleKind = Math.random() > 0.5 ? 'turtle' : 'goomba';
                    this.obstacles.push({
                        x: this.canvas.width + 15,
                        y: this.groundY - pipeHeight - 40,
                        width: 30,
                        height: 40,
                        speed: 4,
                        type: obstacleKind,
                        jumpVelocity: 0,
                        isJumping: false,
                        startY: this.groundY - pipeHeight - 40,
                        frame: 0,
                        frameTime: 0
                    });
                }
            }

            spawnCoinFromBlock(x, y) {
                // Cria uma animação de moeda saindo do bloco
                this.createCoinParticles(x, y);
                this.score += 50;
                this.coinEffect = {x: x - 12, y: y - 12, timer: 20};
            }

            updateBlocks() {
                for (let i = this.blocks.length - 1; i >= 0; i--) {
                    const block = this.blocks[i];
                    block.x -= block.speed;
                    
                    // Efeito de bounce quando atingido
                    if (block.bounceY !== 0) {
                        block.y += block.bounceSpeed;
                        block.bounceSpeed += 1;
                        
                        if (block.y >= block.bounceY) {
                            block.y = block.bounceY;
                            block.bounceY = 0;
                            block.bounceSpeed = 0;
                            
                            // Gerar moeda ou power-up
                            if (!block.hit) {
                                this.spawnCoinFromBlock(block.x + block.width/2, block.y - 40);
                                block.hit = true;
                            }
                        }
                    }
                    
                    // Colisão com Mario por baixo (pular e bater no bloco)
                    if (this.mario.velocityY < 0 && // Mario está pulando
                        this.mario.x + this.mario.width > block.x &&
                        this.mario.x < block.x + block.width &&
                        this.mario.y > block.y && 
                        this.mario.y < block.y + block.height + 10) {
                        
                        if (!block.hit && block.type === 'question') {
                            // Iniciar bounce do bloco
                            block.bounceY = block.y;
                            block.y -= 10;
                            block.bounceSpeed = -5;
                            
                            // Interromper o pulo do Mario
                            this.mario.velocityY = 2;
                            this.sounds.coin();
                        }
                    }
                    
                    // Colisão com Mario (pisar em cima)
                    if (this.mario.velocityY > 0 && // Mario está caindo
                        this.mario.x + this.mario.width > block.x + 5 &&
                        this.mario.x < block.x + block.width - 5 &&
                        this.mario.y + this.mario.height > block.y - 5 && 
                        this.mario.y + this.mario.height < block.y + 15) {
                        
                        this.mario.y = block.y - this.mario.height;
                        this.mario.velocityY = 0;
                        this.mario.isJumping = false;
                    }
                    
                    // NÃO remover blocos fora da tela para manter mundo completo
                    // if (block.x + block.width < 0) {
                    //     this.blocks.splice(i, 1);
                    // }
                }
            }

            updatePlatforms() {
                for (let i = this.platforms.length - 1; i >= 0; i--) {
                    const platform = this.platforms[i];
                    platform.x -= platform.speed;
                    
                    // Colisão com Mario (pisar em cima)
                    if (this.mario.velocityY > 0 && // Mario está caindo
                        this.mario.x + this.mario.width > platform.x + 5 &&
                        this.mario.x < platform.x + platform.width - 5 &&
                        this.mario.y + this.mario.height > platform.y - 5 && 
                        this.mario.y + this.mario.height < platform.y + 15) {
                        
                        this.mario.y = platform.y - this.mario.height;
                        this.mario.velocityY = 0;
                        this.mario.isJumping = false;
                    }
                    
                    // Remover plataformas fora da tela
                    if (platform.x + platform.width < 0) {
                        this.platforms.splice(i, 1);
                    }
                }
            }

            updatePipes() {
                for (let i = this.pipes.length - 1; i >= 0; i--) {
                    const pipe = this.pipes[i];
                    pipe.x -= pipe.speed;
                    
                    // Colisão com Mario (bateu na lateral)
                    if (this.checkCollision(this.mario, pipe)) {
                        // Se o Mario está caindo e no topo do tubo, ele fica em cima
                        if (this.mario.velocityY > 0 && 
                            this.mario.y + this.mario.height < pipe.y + 20) {
                            this.mario.y = pipe.y - this.mario.height;
                            this.mario.velocityY = 0;
                            this.mario.isJumping = false;
                        } else {
                            // Caso contrário, se bateu na lateral e não está invulnerável
                            if (!this.mario.invulnerable) {
                                this.hitEffect = {x: this.mario.x, y: this.mario.y, timer: 20};
                                this.lives--;
                                this.updateHealthBar();
                                this.sounds.hit();
                                this.createHitParticles(this.mario.x, this.mario.y);
                                
                                if (this.lives <= 0) {
                                    this.gameOver();
                                } else {
                                    this.mario.invulnerable = 60;
                                }
                            }
                        }
                    }
                    
                    // Remover tubos fora da tela
                    if (pipe.x + pipe.width < 0) {
                        this.pipes.splice(i, 1);
                    }
                }
            }

            // Sistema de power-ups removido - não é utilizado

            // CORRIGIDO: Modificar o método updateBlocks para NÃO mover os blocos
            // Os blocos devem ter velocidade zero em um mundo estático
            updateBlocks(deltaTime) {
                if (!this.blocks) return;
                
                this.blocks.forEach(block => {
                    // Processar animação de quique (bounce)
                    if (block.bounceY !== undefined && block.bounceSpeed !== undefined) {
                        block.bounceY += block.bounceSpeed;
                        block.bounceSpeed += 0.5; // Gravidade do quique
                        
                        // Retornar à posição original após quicar
                        if (block.bounceY > block.y) {
                            block.bounceY = block.y;
                            block.bounceSpeed = 0;
                        }
                    }
                    
                    // Os blocos NUNCA devem ter movimento horizontal
                    block.speed = 0;
                });
                
                // Remover blocos quebrados após animação
                this.blocks = this.blocks.filter(block => !block.broken || block.bounceY !== block.y);
            }

            update() {
                if (!this.gameRunning || this.gamePaused) return;

                // Verificação de segurança para evitar erros com objetos inexistentes
                if (!this.mario) {
                    console.error("Mario não encontrado no update!");
                    return;
                }

                // Verificação adicional antes de atualizar objetos
                if (!Array.isArray(this.obstacles)) this.obstacles = [];
                if (!Array.isArray(this.blocks)) this.blocks = [];
                if (!Array.isArray(this.platforms)) this.platforms = [];
                if (!Array.isArray(this.pipes)) this.pipes = [];
                if (!Array.isArray(this.coins)) this.coins = [];

                // Inicializar contagem de frames se não existir
                if (this.frameCount === undefined) this.frameCount = 0;
                this.frameCount++;
                
                // Executar limpeza de objetos invisíveis a cada 180 frames (aproximadamente 3 segundos)
                if (this.frameCount % 180 === 0) {
                    this.eliminateInvisibleObjects();
                }

                // Processar controles do Mario com física aprimorada
                if (this.keys.left && this.mario.x > this.cameraX + 10) {
                    this.mario.velocityX += -0.5; // Aceleração gradual
                    this.mario.direction = -1;
                } else if (this.keys.right) {
                    this.mario.velocityX += 0.5; // Aceleração gradual
                    this.mario.direction = 1;
                } else {
                    // Desaceleração gradual quando não há input
                    if (this.mario.velocityX > 0) {
                        this.mario.velocityX -= 0.3;
                    } else if (this.mario.velocityX < 0) {
                        this.mario.velocityX += 0.3;
                    }
                    
                    // Evitar micro-movimentos
                    if (Math.abs(this.mario.velocityX) < 0.3) {
                        this.mario.velocityX = 0;
                    }
                }
                
                // Limitar velocidade máxima
                const maxSpeed = this.mario.onGround ? 7 : 5; // Menor controle no ar
                this.mario.velocityX = Math.max(-maxSpeed, Math.min(maxSpeed, this.mario.velocityX));

                // Atualizar animação do Mario
                if (Math.abs(this.mario.velocityX) > 0.1) {
                    this.mario.frame += 0.2;
                    if (this.mario.frame >= this.mario.frames) this.mario.frame = 0;
                } else {
                    this.mario.frame = 0;
                }

                // Invulnerabilidade
                if (this.mario.invulnerable > 0) {
                    this.mario.invulnerable--;
                }

                // Aplicar física do pulo variável
                if (this.mario.isJumping) {
                    // Maior controle no ar
                    if (this.keys.right) {
                        this.mario.velocityX += 0.2;
                    } else if (this.keys.left) {
                        this.mario.velocityX -= 0.2;
                    }
                    
                    // Pulo variável baseado em quanto tempo o botão é segurado
                    if (this.mario.jumpHoldTime > 0 && this.keys.up && this.mario.velocityY < 0) {
                        this.mario.jumpHoldTime -= 16; // Aproximadamente 16ms por frame
                        this.mario.velocityY -= 0.05; // Prolongar altura do pulo
                    } else {
                        this.mario.jumpHoldTime = 0;
                    }
                }
                
                // Aplicar gravidade (mais suave quando subindo, mais forte quando caindo)
                if (this.mario.velocityY < 0) {
                    this.mario.velocityY += 0.4; // Gravidade durante subida
                } else {
                    this.mario.velocityY += 0.5; // Gravidade durante queda
                }
                
                // Limitar velocidade de queda
                if (this.mario.velocityY > 12) {
                    this.mario.velocityY = 12;
                }

                // Atualizar posição Y do Mario
                this.mario.y += this.mario.velocityY;

                // Verificar colisão com o chão
                if (this.mario.y + this.mario.height >= this.groundY) {
                    this.mario.y = this.groundY - this.mario.height;
                    this.mario.onGround = true;
                    this.mario.velocityY = 0;
                    this.mario.isJumping = false;
                } else {
                    this.mario.onGround = false;
                }

                // Aplicar movimento horizontal
                this.mario.x += this.mario.velocityX;

                // Controle de limites suave - permitir movimento livre
                // Limite esquerdo mais suave, permitindo Mario sair da câmera
                const leftLimit = this.cameraX - 50; // Permitir sair um pouco da tela
                if (this.mario.x < leftLimit) {
                    this.mario.x = leftLimit;
                    this.mario.velocityX = Math.max(0, this.mario.velocityX);
                }

                // Limite direito ajustado para o mapa menor (5400px)
                const rightLimit = this.worldWidth - this.mario.width;
                if (this.mario.x > rightLimit) {
                    this.mario.x = rightLimit;
                    this.mario.velocityX = Math.min(0, this.mario.velocityX);
                }

                // Atualizar câmera
                this.updateCamera();

                // Verificar colisões com plataformas
                this.platforms.forEach(platform => {
                    // Colisão superior (Mario pousando)
                    if (this.mario.x + this.mario.width > platform.x &&
                        this.mario.x < platform.x + platform.width &&
                        this.mario.y + this.mario.height > platform.y &&
                        this.mario.y + this.mario.height < platform.y + platform.height + 10 &&
                        this.mario.velocityY > 0) {
                        this.mario.y = platform.y - this.mario.height;
                        this.mario.onGround = true;
                        this.mario.velocityY = 0;
                        this.mario.isJumping = false;
                    }

                    // Colisão lateral (Mario batendo nas laterais)
                    if (this.mario.y + this.mario.height > platform.y + 10 &&
                        this.mario.y < platform.y + platform.height - 10) {
                        // Colisão pela esquerda
                        if (this.mario.x + this.mario.width > platform.x &&
                            this.mario.x + this.mario.width < platform.x + 20 &&
                            this.mario.velocityX > 0) {
                            this.mario.x = platform.x - this.mario.width;
                            this.mario.velocityX = 0;
                        }
                        // Colisão pela direita
                        if (this.mario.x < platform.x + platform.width &&
                            this.mario.x > platform.x + platform.width - 20 &&
                            this.mario.velocityX < 0) {
                            this.mario.x = platform.x + platform.width;
                            this.mario.velocityX = 0;
                        }
                    }
                });

                // Verificar colisões com blocos (versão melhorada)
                this.checkBlockCollisions();

                // Atualizar blocos (animação de quique, etc)
                this.updateBlocks(1/60); // Aproximação de deltaTime para 60fps

                // Verificar colisões com tubos
                this.pipes.forEach(pipe => {
                    if (this.mario.x + this.mario.width > pipe.x &&
                        this.mario.x < pipe.x + pipe.width &&
                        this.mario.y + this.mario.height > pipe.y &&
                        this.mario.y < pipe.y + pipe.height) {
                        
                        // Colisão superior (Mario pousando)
                        if (this.mario.velocityY > 0 &&
                            this.mario.y + this.mario.height - this.mario.velocityY <= pipe.y) {
                            this.mario.y = pipe.y - this.mario.height;
                            this.mario.onGround = true;
                            this.mario.velocityY = 0;
                            this.mario.isJumping = false;
                        } else {
                            // Colisões laterais
                            if (this.mario.velocityX > 0) {
                                this.mario.x = pipe.x - this.mario.width;
                            } else if (this.mario.velocityX < 0) {
                                this.mario.x = pipe.x + pipe.width;
                            }
                            this.mario.velocityX = 0;
                        }
                    }
                });

                // Atualizar inimigos com comportamentos específicos
                this.obstacles.forEach((enemy, index) => {
                    // Incrementar contador de frames para animações
                    this.frameCount = (this.frameCount || 0) + 1;
                    
                    // Obter e aplicar comportamento específico do inimigo
                    const behavior = this.getEnemyBehavior(enemy.type);
                    if (behavior) {
                        behavior(enemy);
                    }

                    // Atualizar frames de animação
                    enemy.frameTime++;
                    if (enemy.frameTime >= 15) {
                        enemy.frame = (enemy.frame + 1) % 2;
                        enemy.frameTime = 0;
                    }

                    // Verificar colisão com Mario (apenas se não estiver invulnerável)
                    if (this.mario.invulnerable === 0 &&
                        this.mario.x + this.mario.width > enemy.x &&
                        this.mario.x < enemy.x + enemy.width &&
                        this.mario.y + this.mario.height > enemy.y &&
                        this.mario.y < enemy.y + enemy.height) {
                        
                        // Mario pulando em cima do inimigo
                        if (this.mario.velocityY > 0 && 
                            this.mario.y + this.mario.height - this.mario.velocityY <= enemy.y) {
                            
                            // Destruir inimigo
                            this.obstacles.splice(index, 1);
                            this.score += 200;
                            this.mario.velocityY = -10; // Pequeno pulo
                            this.createEnemyDefeatedEffect(enemy.x, enemy.y);
                            this.playSound(this.sounds.jump);
                        } else {
                            // Mario foi atingido
                            this.takeDamage();
                            return;
                        }
                    }

                    // Remover inimigos que saíram muito para trás da câmera
                    if (enemy.x + enemy.width < this.cameraX - 200) {
                        this.obstacles.splice(index, 1);
                    }
                });

                // Verificar coleta de moedas
                this.coins.forEach((coin, index) => {
                    coin.angle += 0.1;
                    coin.shine = (coin.shine + 1) % 60;
                    
                    if (this.mario.x + this.mario.width > coin.x &&
                        this.mario.x < coin.x + coin.width &&
                        this.mario.y + this.mario.height > coin.y &&
                        this.mario.y < coin.y + coin.height) {
                        
                        this.coins.splice(index, 1);
                        this.score += 10;
                        this.spawnCoin(coin.x, coin.y, false);
                        this.playSound(this.sounds.coin);
                    }
                });

                // Atualizar moedas animadas (as que saem dos blocos)
                if (this.animatedCoins) {
                    this.animatedCoins.forEach((coin, index) => {
                        coin.velocityY += 0.5;
                        coin.y += coin.velocityY;
                        coin.life--;
                        
                        if (coin.life <= 0) {
                            this.animatedCoins.splice(index, 1);
                        }
                    });
                }

                // Atualizar partículas
                if (this.particles) {
                    this.particles = this.particles.filter(particle => {
                        // Atualizar posição
                        particle.x += particle.speedX || particle.vx || 0;
                        particle.y += particle.speedY || particle.vy || 0;
                        
                        // Aplicar gravidade se definida
                        if (particle.gravity) {
                            particle.speedY = (particle.speedY || 0) + particle.gravity;
                        } else {
                            particle.vy = (particle.vy || 0) + 0.1;
                        }
                        
                        // Diminuir vida
                        particle.life = (particle.life || 0) - 1;
                        
                        // Diminuir opacidade com o tempo
                        if (particle.opacity !== undefined) {
                            particle.opacity = Math.max(0, particle.opacity - 0.02);
                        }
                        
                        // Retornar true se a partícula ainda deve existir
                        return particle.life > 0;
                    });
                }

                // Atualizar nuvens com movimento suave
                this.clouds.forEach(cloud => {
                    cloud.x += cloud.speed;
                    
                    // Wrap around quando a nuvem sai da tela
                    if (cloud.x > this.worldWidth + 100) {
                        cloud.x = -cloud.width - 100;
                        cloud.y = 30 + Math.random() * 120; // Nova altura aleatória
                    }
                });

                // Verificar se há objetos inválidos e removê-los
                if (this.frameCount % 300 === 0) { // A cada 5 segundos aproximadamente
                    this.eliminateInvisibleObjects();
                }
                
                // Verificar final do jogo
                this.checkEndGame();

                // Verificar Game Over
                if (this.mario.y > this.canvas.height) {
                    this.takeDamage();
                }

                // Aplicar fricção
                this.mario.velocityX *= 0.85;

                // Atualizar elementos da UI
                this.scoreElement.textContent = this.score;
                this.updateHealthBar();
            }

            checkCollision(rect1, rect2) {
                return rect1.x < rect2.x + rect2.width &&
                       rect1.x + rect1.width > rect2.x &&
                       rect1.y < rect2.y + rect2.height &&
                       rect1.y + rect1.height > rect2.y;
            }

            draw() {
                // Clear canvas
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                // Salvar contexto para aplicar offset da câmera
                this.ctx.save();
                this.ctx.translate(-this.cameraX, 0);
                
                // Draw background layers (parallax) - background não move com a câmera
                this.ctx.restore();
                this.drawBackground();
                this.ctx.save();
                this.ctx.translate(-this.cameraX, 0);

                // Draw clouds com parallax
                this.drawClouds();
                
                // Draw ground with details (agora sempre marrom/verde, nunca azul)
                this.drawGround();

                // Draw platforms
                this.drawPlatforms();
                
                // Draw pipes
                this.drawPipes();
                
                // Draw blocks
                this.drawBlocks();

                // Draw coins
                this.drawCoins();

                // Draw Mario
                this.drawMario();

                // Draw obstacles (inimigos)
                this.obstacles.forEach(obstacle => {
                    if (obstacle.type === 'goomba') {
                        this.drawGoomba(obstacle);
                    } else if (obstacle.type === 'turtle') {
                        this.drawTurtle(obstacle);
                    } else if (obstacle.type === 'flying') {
                        this.drawFlyingEnemy(obstacle);
                    } else if (obstacle.type === 'jumping') {
                        this.drawJumpingEnemy(obstacle);
                    } else {
                        this.drawTurtle(obstacle); // fallback
                    }
                });

                // Draw particles
                this.drawParticles();

                // Draw ground with details
                this.drawGround();
                
                // Draw end area (castle and flag)
                this.drawEndArea();

                // Draw score effects
                this.drawScoreEffects();

                // Restaurar contexto
                this.ctx.restore();

                // Elementos de UI não são afetados pela câmera
                // Feedback visual de colisão
                if (this.hitEffect && this.hitEffect.timer > 0) {
                    this.ctx.save();
                    this.ctx.globalAlpha = this.hitEffect.timer / 20;
                    this.ctx.fillStyle = '#FF6B6B';
                    this.ctx.fillRect(this.hitEffect.x - this.cameraX, this.hitEffect.y, this.mario.width, this.mario.height);
                    this.ctx.restore();
                    this.hitEffect.timer--;
                }

                // Efeito visual ao coletar moeda
                if (this.coinEffect && this.coinEffect.timer > 0) {
                    this.ctx.save();
                    this.ctx.globalAlpha = this.coinEffect.timer / 20;
                    this.ctx.beginPath();
                    this.ctx.arc(this.coinEffect.x + 12 - this.cameraX, this.coinEffect.y + 12, 30 - this.coinEffect.timer, 0, Math.PI * 2);
                    this.ctx.fillStyle = '#FFFF99';
                    this.ctx.fill();
                    this.ctx.restore();
                    this.coinEffect.timer--;
                }
                
                // Desenhar visuais de debug se ativados
                if (this.showDebugVisuals) {
                    this.drawDebugVisuals();
                }
                
                // Interface do jogo renderizada por último
            }
            
            drawMario() {
                // Corpo principal
                this.ctx.fillStyle = '#FF0000';
                this.ctx.fillRect(this.mario.x, this.mario.y, this.mario.width, this.mario.height);
                
                // Macacão
                this.ctx.fillStyle = '#4166F5';
                this.ctx.fillRect(this.mario.x, this.mario.y + 25, this.mario.width, this.mario.height - 25);
                
                // Braços
                const armOffset = this.mario.isJumping ? 5 : Math.sin(this.mario.frame * 0.5) * 5;
                this.ctx.fillStyle = '#FF0000';
                if (this.mario.direction > 0) {
                    this.ctx.fillRect(this.mario.x + this.mario.width - 5, this.mario.y + 15 + armOffset, 10, 15);
                } else {
                    this.ctx.fillRect(this.mario.x - 5, this.mario.y + 15 + armOffset, 10, 15);
                }
                
                // Rosto e detalhes
                this.ctx.fillStyle = '#FFDBAC';
                this.ctx.fillRect(this.mario.x + (this.mario.direction > 0 ? 10 : 5), 
                                this.mario.y + 5, 
                                25, 20);
                
                // Olhos
                this.ctx.fillStyle = '#000';
                this.ctx.fillRect(this.mario.x + (this.mario.direction > 0 ? 25 : 10), 
                                this.mario.y + 10, 
                                5, 5);
                
                // Bigode
                this.ctx.fillRect(this.mario.x + (this.mario.direction > 0 ? 15 : 5), 
                                this.mario.y + 18, 
                                20, 3);
                
                // Chapéu
                this.ctx.fillStyle = '#FF0000';
                this.ctx.fillRect(this.mario.x + (this.mario.direction > 0 ? 5 : 0), 
                                this.mario.y, 
                                this.mario.width - 5, 10);
                
                // Pernas em animação
                const legOffset = this.mario.isJumping ? 0 : Math.sin(this.mario.frame * Math.PI) * 5;
                
                // Perna esquerda
                this.ctx.fillStyle = '#4166F5';
                this.ctx.fillRect(this.mario.x + 5, 
                                this.mario.y + this.mario.height - 15, 
                                10, 15 + (this.mario.isJumping ? 0 : legOffset));
                
                // Perna direita
                this.ctx.fillRect(this.mario.x + this.mario.width - 15, 
                                this.mario.y + this.mario.height - 15, 
                                10, 15 + (this.mario.isJumping ? 0 : -legOffset));
                
                // Sapatos
                this.ctx.fillStyle = '#654321';
                this.ctx.fillRect(this.mario.x + 3, 
                                this.mario.y + this.mario.height - 5, 
                                14, 5);
                this.ctx.fillRect(this.mario.x + this.mario.width - 17, 
                                this.mario.y + this.mario.height - 5, 
                                14, 5);
            }
            
            drawGoomba(obstacle) {
                // Corpo
                this.ctx.fillStyle = '#8B4513';
                this.ctx.fillRect(obstacle.x, obstacle.y, obstacle.width, obstacle.height);
                
                // Corpo arredondado
                this.ctx.fillStyle = '#A0522D';
                this.ctx.beginPath();
                this.ctx.arc(obstacle.x + obstacle.width/2, obstacle.y + 15, 15, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Olhos
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(obstacle.x + 10, obstacle.y + 10, 5, 0, Math.PI * 2);
                this.ctx.arc(obstacle.x + 20, obstacle.y + 10, 5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Pupilas
                this.ctx.fillStyle = '#000';
                this.ctx.beginPath();
                this.ctx.arc(obstacle.x + 10, obstacle.y + 10, 2, 0, Math.PI * 2);
                this.ctx.arc(obstacle.x + 20, obstacle.y + 10, 2, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Pernas em movimento
                this.ctx.fillStyle = '#8B4513';
                const legOffset = Math.sin(obstacle.frame * Math.PI) * 3;
                this.ctx.fillRect(obstacle.x + 5, obstacle.y + obstacle.height - 8, 8, 8 + legOffset);
                this.ctx.fillRect(obstacle.x + obstacle.width - 13, obstacle.y + obstacle.height - 8, 8, 8 - legOffset);
            }
            
            drawTurtle(obstacle) {
                // Casco
                this.ctx.fillStyle = '#00AA00';
                this.ctx.beginPath();
                this.ctx.arc(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, 18, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Padrão do casco
                this.ctx.fillStyle = '#008800';
                this.ctx.beginPath();
                this.ctx.arc(obstacle.x + obstacle.width/2, obstacle.y + obstacle.height/2, 12, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Cabeça
                this.ctx.fillStyle = '#00CC00';
                this.ctx.beginPath();
                this.ctx.arc(obstacle.x + obstacle.width/2 - 10, obstacle.y + 10, 8, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Olhos
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(obstacle.x + obstacle.width/2 - 12, obstacle.y + 8, 3, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Pupilas
                this.ctx.fillStyle = '#000';
                this.ctx.beginPath();
                this.ctx.arc(obstacle.x + obstacle.width/2 - 12, obstacle.y + 8, 1.5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Pernas
                this.ctx.fillStyle = '#00CC00';
                const legOffset = Math.sin(obstacle.frame * Math.PI) * 3;
                this.ctx.fillRect(obstacle.x + 5, obstacle.y + obstacle.height - 8, 8, 8 + legOffset);
                this.ctx.fillRect(obstacle.x + obstacle.width - 13, obstacle.y + obstacle.height - 8, 8, 8 - legOffset);
            }
            
            drawFlyingEnemy(enemy) {
                // Corpo principal (mais alongado para inimigo voador)
                this.ctx.fillStyle = '#800080'; // Roxo para diferenciá-lo
                this.ctx.fillRect(enemy.x, enemy.y + 5, enemy.width, enemy.height - 10);
                
                // Asas (animação de batida)
                const wingFlap = Math.sin(enemy.x / 10) * 5; // Animação baseada na posição
                this.ctx.fillStyle = '#A020F0';
                
                // Asa esquerda
                this.ctx.fillRect(enemy.x - 8, enemy.y + wingFlap, 12, 15);
                // Asa direita
                this.ctx.fillRect(enemy.x + enemy.width - 4, enemy.y + wingFlap, 12, 15);
                
                // Olhos
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(enemy.x + enemy.width/2 - 8, enemy.y + 8, 4, 0, Math.PI * 2);
                this.ctx.arc(enemy.x + enemy.width/2 + 8, enemy.y + 8, 4, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Pupilas
                this.ctx.fillStyle = '#000';
                this.ctx.beginPath();
                this.ctx.arc(enemy.x + enemy.width/2 - 8, enemy.y + 8, 2, 0, Math.PI * 2);
                this.ctx.arc(enemy.x + enemy.width/2 + 8, enemy.y + 8, 2, 0, Math.PI * 2);
                this.ctx.fill();
            }
            
            drawJumpingEnemy(enemy) {
                // Corpo principal (formato de mola)
                this.ctx.fillStyle = '#FF4500'; // Laranja
                this.ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);
                
                // Efeito de mola (linhas horizontais)
                this.ctx.strokeStyle = '#FF6347';
                this.ctx.lineWidth = 2;
                for (let i = 1; i < 4; i++) {
                    const y = enemy.y + (enemy.height / 4) * i;
                    this.ctx.beginPath();
                    this.ctx.moveTo(enemy.x + 3, y);
                    this.ctx.lineTo(enemy.x + enemy.width - 3, y);
                    this.ctx.stroke();
                }
                
                // Olhos
                this.ctx.fillStyle = '#FFFFFF';
                this.ctx.beginPath();
                this.ctx.arc(enemy.x + enemy.width/2 - 6, enemy.y + 8, 3, 0, Math.PI * 2);
                this.ctx.arc(enemy.x + enemy.width/2 + 6, enemy.y + 8, 3, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Pupilas
                this.ctx.fillStyle = '#000';
                this.ctx.beginPath();
                this.ctx.arc(enemy.x + enemy.width/2 - 6, enemy.y + 8, 1.5, 0, Math.PI * 2);
                this.ctx.arc(enemy.x + enemy.width/2 + 6, enemy.y + 8, 1.5, 0, Math.PI * 2);
                this.ctx.fill();
                
                // Base (para mostrar que é uma mola)
                if (!enemy.isJumping) {
                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.fillRect(enemy.x - 2, enemy.y + enemy.height, enemy.width + 4, 3);
                }
            }
            
            drawCoins() {
                this.coins.forEach(coin => {
                    // Efeito de rotação da moeda
                    const coinWidth = Math.abs(Math.cos(coin.angle) * coin.width);
                    
                    // Contorno dourado
                    this.ctx.fillStyle = '#FFC125';
                    this.ctx.beginPath();
                    this.ctx.ellipse(
                        coin.x + coin.width/2, 
                        coin.y + coin.height/2,
                        coinWidth/2 + 2, 
                        coin.height/2 + 2, 
                        0, 0, Math.PI * 2
                    );
                    this.ctx.fill();
                    
                    // Moeda dourada
                    this.ctx.fillStyle = '#FFD700';
                    this.ctx.beginPath();
                    this.ctx.ellipse(
                        coin.x + coin.width/2, 
                        coin.y + coin.height/2,
                        coinWidth/2, 
                        coin.height/2, 
                        0, 0, Math.PI * 2
                    );
                    this.ctx.fill();
                    
                    // Brilho da moeda
                    if (coin.shine < 15) {
                        this.ctx.fillStyle = '#FFFFFF';
                        this.ctx.globalAlpha = 0.7;
                        this.ctx.beginPath();
                        this.ctx.arc(
                            coin.x + coin.width/2 - coinWidth/4, 
                            coin.y + coin.height/2 - coin.height/4,
                            3, 0, Math.PI * 2
                        );
                        this.ctx.fill();
                        this.ctx.globalAlpha = 1.0;
                    }
                    
                    // Detalhe "C" na moeda
                    if (coinWidth > coin.width * 0.7) {
                        this.ctx.fillStyle = '#E5A900';
                        this.ctx.font = '15px Arial';
                        this.ctx.textAlign = 'center';
                        this.ctx.fillText("C", coin.x + coin.width/2, coin.y + coin.height/2 + 5);
                    }
                });
            }
            
            drawGround() {
                // SOLUÇÃO DEFINITIVA: Sempre desenhar chão de terra, NUNCA azul
                // Desenhar base marrom sólida para todo o chão visível
                this.ctx.fillStyle = '#8B4513'; // Marrom para terra (sempre)
                this.ctx.fillRect(this.cameraX, this.groundY, this.canvas.width, this.canvas.height - this.groundY);
                
                // Desenhar camada de grama em todo o chão
                this.ctx.fillStyle = '#32CD32'; // Verde para grama
                this.ctx.fillRect(this.cameraX, this.groundY, this.canvas.width, 6);
                
                // Detalhes de textura consistentes e determinísticos
                const startX = Math.floor(this.cameraX / 40) * 40;
                const endX = startX + this.canvas.width + 40;
                
                for (let x = startX; x < endX; x += 40) {
                    // Coordenadas relativas à câmera
                    const drawX = x - this.cameraX;
                    
                    // Usar hash simples baseado na posição X para determinismo
                    const seed = ((x * 1234) % 9973) / 9973;
                    
                    // Textura de terra determinística (sem aleatoriedade)
                    this.ctx.fillStyle = '#7D3511';
                    for (let i = 0; i < 5; i++) {
                        const tx = drawX + ((seed * 30) + i * 7) % 40;
                        const ty = this.groundY + 10 + ((seed * 60) + i * 12) % (this.canvas.height - this.groundY - 15);
                        this.ctx.fillRect(tx, ty, 3, 3);
                    }
                    
                    // Detalhes de grama determinísticos
                    this.ctx.fillStyle = '#228B22';
                    for (let i = 0; i < 8; i++) {
                        const gx = drawX + ((seed * 40) + i * 5) % 40;
                        const height = 2 + ((seed * 3) + i) % 4;
                        this.ctx.fillRect(gx, this.groundY - height, 2, height);
                    }
                }
            }

            drawClouds() {
                this.clouds.forEach(cloud => {
                    // Verificar se a nuvem está visível na tela
                    if (cloud.x + cloud.width < this.cameraX - 100 || 
                        cloud.x > this.cameraX + this.canvas.width + 100) return;
                    
                    this.ctx.save();
                    this.ctx.globalAlpha = cloud.opacity;
                    this.ctx.fillStyle = '#FFFFFF';
                    
                    // Corpo principal da nuvem
                    this.ctx.beginPath();
                    this.ctx.arc(cloud.x + cloud.width * 0.3, cloud.y + cloud.height * 0.6, cloud.width * 0.25, 0, Math.PI * 2);
                    this.ctx.arc(cloud.x + cloud.width * 0.6, cloud.y + cloud.height * 0.4, cloud.width * 0.3, 0, Math.PI * 2);
                    this.ctx.arc(cloud.x + cloud.width * 0.8, cloud.y + cloud.height * 0.7, cloud.width * 0.2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    // Adicionar detalhes para tornar mais realística
                    cloud.details.forEach(detail => {
                        this.ctx.beginPath();
                        this.ctx.arc(
                            cloud.x + detail.x, 
                            cloud.y + detail.y, 
                            detail.width * 0.15, 
                            0, 
                            Math.PI * 2
                        );
                        this.ctx.fill();
                    });
                    
                    // Sombra sutil
                    this.ctx.globalAlpha = cloud.opacity * 0.3;
                    this.ctx.fillStyle = '#E0E0E0';
                    this.ctx.beginPath();
                    this.ctx.arc(cloud.x + cloud.width * 0.4, cloud.y + cloud.height * 0.8, cloud.width * 0.2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.restore();
                });
            }

            // CORRIGIDO: Modificar o método drawBlocks para garantir renderização correta
            drawBlocks() {
                let drawnBlocks = 0; // Contador de blocos realmente desenhados
                
                this.blocks.forEach(block => {
                    // Calcular posição de desenho relativa à câmera
                    const drawX = block.x - this.cameraX;
                    
                    // Só desenhar blocos visíveis (otimização) - critério mais rigoroso
                    if (drawX >= -20 && drawX + block.width <= this.canvas.width + 20 && !block.broken) {
                        drawnBlocks++; // Incrementar contador
                        
                        // Ajustar posição Y para efeito de quique
                        const drawY = block.bounceY || block.y;
                        
                        // DEBUG: Desenhar contorno vermelho para visualizar área de colisão
                        // this.ctx.strokeStyle = 'red';
                        // this.ctx.strokeRect(drawX, block.y, block.width, block.height);
                        
                        if (block.type === 'brick') {
                            // Tijolo normal (marrom)
                            if (!block.broken) {
                                this.ctx.fillStyle = '#8B4513';
                                this.ctx.fillRect(drawX, drawY, block.width, block.height);
                                
                                // Detalhes do tijolo
                                this.ctx.fillStyle = '#A0522D';
                                this.ctx.fillRect(drawX + 2, drawY + 2, block.width - 4, 3);
                                this.ctx.fillRect(drawX + 2, drawY + block.height - 5, block.width - 4, 3);
                            }
                        } else if (block.type === 'question') {
                            // Bloco de pergunta
                            if (!block.hit) {
                                // Bloco amarelo pulsante
                                const glowFactor = Math.sin(Date.now() / 200) * 0.1 + 0.9;
                                this.ctx.fillStyle = `rgb(255, ${Math.floor(215 * glowFactor)}, 0)`;
                            } else {
                                // Bloco já usado (cinza)
                                this.ctx.fillStyle = '#808080';
                            }
                            this.ctx.fillRect(drawX, drawY, block.width, block.height);
                            
                            // Símbolo de interrogação
                            if (!block.hit) {
                                this.ctx.fillStyle = '#FFFFFF';
                                this.ctx.font = '20px Arial';
                                this.ctx.fillText('?', drawX + 9, drawY + 18);
                            }
                        }
                    }
                });
                
                // Registrar número de blocos desenhados a cada segundo
                if (this.frameCount % 60 === 0) {
                    console.log(`Blocos renderizados: ${drawnBlocks}`);
                }
            }

            drawPlatforms() {
                this.platforms.forEach(platform => {
                    // Base da plataforma
                    this.ctx.fillStyle = '#A0522D';
                    this.ctx.fillRect(platform.x, platform.y, platform.width, platform.height);
                    
                    // Topo da plataforma (grama)
                    this.ctx.fillStyle = '#32CD32';
                    this.ctx.fillRect(platform.x, platform.y, platform.width, 6);
                    
                    // Detalhes na plataforma
                    this.ctx.fillStyle = '#8B4513';
                    for (let i = 0; i < platform.width - 10; i += 20) {
                        this.ctx.fillRect(platform.x + 5 + i, platform.y + 10, 10, 5);
                    }
                });
            }

            drawPipes() {
                this.pipes.forEach(pipe => {
                    // Corpo principal do tubo (verde)
                    this.ctx.fillStyle = '#00AA00';
                    this.ctx.fillRect(pipe.x, pipe.y, pipe.width, pipe.height);
                    
                    // Topo do tubo
                    this.ctx.fillStyle = '#00CC00';
                    this.ctx.fillRect(pipe.x - 5, pipe.y, pipe.width + 10, 15);
                    
                    // Detalhes/sombras
                    this.ctx.fillStyle = '#008800';
                    this.ctx.fillRect(pipe.x + pipe.width - 10, pipe.y, 10, pipe.height);
                });
            }

            gameOver() {
                this.gameRunning = false;
                this.sounds.gameOver();
                // Atualiza recorde se necessário
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem('highScore', this.highScore);
                }
                this.finalScoreElement.textContent = this.score;
                this.gameOverElement.style.display = 'block';
                this.updateScoreDisplay();
            }
            updateScoreDisplay() {
                this.scoreElement.textContent = `Pontos: ${this.score} | Recorde: ${this.highScore} | Vidas: ${this.lives}`;
            }

            restart() {
                this.gameOverElement.style.display = 'none';
                this.init();
            }
            
            animateMenu() {
                if (!this.gameRunning && !this.gamePaused) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    
                    // Desenha fundo animado para o menu
                    this.drawBackground();
                    this.drawClouds();
                    this.drawGround();
                    
                    // Move background lentamente
                    this.backgroundX -= 0.5;
                    if (this.backgroundX <= -this.canvas.width) this.backgroundX = 0;
                    
                    requestAnimationFrame(() => this.animateMenu());
                }
            }

            gameLoop() {
                if (!this.gameRunning) return;
                
                if (!this.gamePaused) {
                    this.update();
                    this.draw();
                }
                
                requestAnimationFrame(() => this.gameLoop());
            }
            
            drawBackground() {
                // Gradiente de céu
                const gradient = this.ctx.createLinearGradient(0, 0, 0, this.groundY);
                gradient.addColorStop(0, '#5D92B1');
                gradient.addColorStop(1, '#87CEEB');
                this.ctx.fillStyle = gradient;
                this.ctx.fillRect(0, 0, this.canvas.width, this.groundY);
                
                // Montanhas ao fundo
                this.drawMountains();
            }
            
            drawMountains() {
                // Montanhas distantes
                this.ctx.fillStyle = '#8BB9A8';
                for (let i = 0; i < 5; i++) {
                    const x = ((i * 500) + this.backgroundX * 0.2) % (this.canvas.width + 500) - 250;
                    const height = 100 + Math.sin(i) * 50;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x - 200, this.groundY);
                    this.ctx.lineTo(x, this.groundY - height);
                    this.ctx.lineTo(x + 200, this.groundY);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
                
                // Montanhas mais próximas
                this.ctx.fillStyle = '#75A28B';
                for (let i = 0; i < 3; i++) {
                    const x = ((i * 800) + this.backgroundX * 0.5) % (this.canvas.width + 800) - 200;
                    const height = 150 + Math.cos(i) * 50;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(x - 300, this.groundY);
                    this.ctx.lineTo(x, this.groundY - height);
                    this.ctx.lineTo(x + 300, this.groundY);
                    this.ctx.closePath();
                    this.ctx.fill();
                }
            }
            
            drawParticles() {
                if (!this.particles) return;
                
                this.particles.forEach(particle => {
                    const drawX = particle.x - this.cameraX;
                    const drawY = particle.y;
                    
                    // Verificar se está visível na tela
                    if (drawX >= -20 && drawX <= this.canvas.width + 20 &&
                        drawY >= -20 && drawY <= this.canvas.height + 20) {
                        
                        this.ctx.save();
                        
                        // Usar opacidade definida ou calcular baseado na vida
                        if (particle.opacity !== undefined) {
                            this.ctx.globalAlpha = particle.opacity;
                        } else if (particle.maxLife) {
                            this.ctx.globalAlpha = particle.life / particle.maxLife;
                        } else {
                            this.ctx.globalAlpha = Math.min(1, particle.life / 30);
                        }
                        
                        this.ctx.fillStyle = particle.color;
                        
                        if (particle.size) {
                            // Partícula retangular com tamanho personalizado
                            this.ctx.fillRect(drawX, drawY, particle.size, particle.size);
                        } else {
                            // Partícula circular padrão
                            this.ctx.beginPath();
                            this.ctx.arc(drawX, drawY, 3, 0, Math.PI * 2);
                            this.ctx.fill();
                        }
                        
                        this.ctx.restore();
                    }
                });
            }
            
            // Sistema de água removido - método não necessário

            // Método para desenhar castelo e bandeira
            drawEndArea() {
                // Desenhar castelo
                if (this.castle) {
                    const drawX = this.castle.x;
                    
                    // Base do castelo
                    this.ctx.fillStyle = '#808080';
                    this.ctx.fillRect(drawX, this.castle.y, this.castle.width, this.castle.height);
                    
                    // Porta
                    this.ctx.fillStyle = '#000000';
                    this.ctx.fillRect(drawX + this.castle.width/2 - 25, this.castle.y + this.castle.height - 50, 50, 50);
                    
                    // Torres
                    this.ctx.fillStyle = '#606060';
                    this.ctx.fillRect(drawX - 10, this.castle.y, 30, 60);
                    this.ctx.fillRect(drawX + this.castle.width - 20, this.castle.y, 30, 60);
                    
                    // Detalhes das torres
                    for (let i = 0; i < 3; i++) {
                        this.ctx.fillStyle = '#404040';
                        this.ctx.fillRect(drawX - 5 + (i * 10), this.castle.y - 15, 5, 15);
                        this.ctx.fillRect(drawX + this.castle.width - 15 + (i * 10), this.castle.y - 15, 5, 15);
                    }
                    
                    // Janelas
                    for (let i = 0; i < 3; i++) {
                        for (let j = 0; j < 2; j++) {
                            this.ctx.fillStyle = '#87CEEB';
                            this.ctx.fillRect(drawX + 40 + (i * 50), this.castle.y + 40 + (j * 50), 20, 20);
                        }
                    }
                }
                
                // Desenhar bandeira
                if (this.flag) {
                    const drawX = this.flag.x;
                    
                    // Mastro
                    this.ctx.fillStyle = '#8B4513';
                    this.ctx.fillRect(drawX, this.flag.y, 8, this.flag.height);
                    
                    // Bandeira
                    this.ctx.fillStyle = '#FF0000';
                    
                    // Animar subida da bandeira quando o jogo terminar
                    const flagHeight = 40;
                    const flagY = this.flag.raised ? this.flag.y : this.flag.y + this.flag.height - 50;
                    
                    this.ctx.beginPath();
                    this.ctx.moveTo(drawX + 8, flagY);
                    this.ctx.lineTo(drawX + 38, flagY + flagHeight/2);
                    this.ctx.lineTo(drawX + 8, flagY + flagHeight);
                    this.ctx.fill();
                }
            }

            // Método para validação completa do jogo
            validateGame() {
                console.log("Iniciando validação completa do jogo...");
                
                // Validar física dos blocos
                this.validateBlockPhysics();
                
                // Validar região final do jogo
                this.validateEndArea();
                
                console.log("Validação completa finalizada.");
            }

            // Sistema de água removido - método não necessário

            // Validar física dos blocos
            validateBlockPhysics() {
                console.log("Validando física dos blocos...");
                
                // Verificar se há blocos de teste e remover duplicatas
                const testX = 500;
                
                // Remover blocos sobrepostos na área de teste
                this.blocks = this.blocks.filter((block, index, array) => {
                    const duplicates = array.filter(b => 
                        Math.abs(b.x - block.x) < 10 && Math.abs(b.y - block.y) < 10
                    );
                    return duplicates[0] === block; // Manter apenas o primeiro
                });
                
                console.log("Blocos validados:", this.blocks.length);
            }

            // Validar região final do jogo
            validateEndArea() {
                console.log("Validando área final do jogo...");
                
                // Verificar se castelo e bandeira existem e estão na posição correta
                if (!this.castle || !this.flag) {
                    console.error("Castelo ou bandeira não encontrados!");
                    return;
                }
                
                console.log("Posição do castelo:", this.castle.x, "Fim do mundo:", this.worldWidth);
                
                // Garantir que não haja obstáculos bloqueando o caminho para o castelo
                const castleX = this.castle.x;
                const clearZone = 400; // 400px de zona livre
                
                // Contar obstáculos removidos
                const originalBlocks = this.blocks.length;
                const originalObstacles = this.obstacles.length;
                
                // Remover qualquer objeto que possa estar bloqueando o caminho final
                this.blocks = this.blocks.filter(block => 
                    block.x < castleX - clearZone || block.x > castleX + this.castle.width + 50
                );
                
                this.obstacles = this.obstacles.filter(obstacle => 
                    obstacle.x < castleX - clearZone || obstacle.x > castleX + this.castle.width + 50
                );
                
                this.pipes = this.pipes.filter(pipe => 
                    pipe.x < castleX - clearZone || pipe.x > castleX + this.castle.width + 50
                );
                
                console.log(`Zona final limpa: removidos ${originalBlocks - this.blocks.length} blocos e ${originalObstacles - this.obstacles.length} obstáculos`);
                
                // Adicionar plataformas para facilitar acesso ao castelo se necessário
                const hasPlatformsToCastle = this.platforms.some(platform => 
                    platform.x > castleX - clearZone && platform.x < castleX
                );
                
                if (!hasPlatformsToCastle) {
                    this.platforms.push({
                        x: castleX - 200,
                        y: this.groundY - 60,
                        width: 150,
                        height: 20,
                        speed: 0
                    });
                    console.log("Plataforma de acesso ao castelo adicionada");
                }
                
                console.log("Área final validada com sucesso");
            }

            // Métodos de debug visual para diagnóstico
            toggleDebugVisuals() {
                this.showDebugVisuals = !this.showDebugVisuals;
                console.log(`Debug visuals: ${this.showDebugVisuals ? 'ON' : 'OFF'}`);
            }

            drawDebugVisuals() {
                // Visualizar hitbox do Mario
                this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.8)';
                this.ctx.lineWidth = 2;
                this.ctx.strokeRect(
                    this.mario.x - this.cameraX, 
                    this.mario.y, 
                    this.mario.width, 
                    this.mario.height
                );
                
                // Visualizar hitbox da cabeça do Mario
                this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                const headHitbox = {
                    x: this.mario.x + this.mario.width * 0.2 - this.cameraX,
                    width: this.mario.width * 0.6,
                    y: this.mario.y,
                    height: 10
                };
                this.ctx.strokeRect(
                    headHitbox.x, 
                    headHitbox.y, 
                    headHitbox.width, 
                    headHitbox.height
                );
                
                // MELHORADO: Visualizar blocos com cores diferentes para margens e área visível
                this.blocks.forEach(block => {
                    if (block.broken) return;
                    
                    const drawX = block.x - this.cameraX;
                    const isVisible = drawX >= -20 && drawX + block.width <= this.canvas.width + 20;
                    const isInCollisionRange = drawX >= -100 && drawX <= this.canvas.width + 100;
                    
                    // Cores diferentes baseadas na visibilidade
                    if (isVisible) {
                        // Verde para blocos visíveis na tela
                        this.ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
                    } else if (isInCollisionRange) {
                        // Amarelo para blocos na margem de colisão, mas não visíveis
                        this.ctx.strokeStyle = 'rgba(255, 255, 0, 0.8)';
                    } else {
                        // Vermelho para blocos completamente fora da área
                        this.ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                    }
                    
                    this.ctx.strokeRect(drawX, block.y, block.width, block.height);
                    
                    // Mostrar informações do bloco
                    if (isVisible || isInCollisionRange) {
                        this.ctx.fillStyle = 'white';
                        this.ctx.font = '8px Arial';
                        this.ctx.fillText(
                            `${Math.floor(block.x)},${Math.floor(block.y)}`, 
                            drawX, 
                            block.y - 3
                        );
                    }
                });
                
                // Mostrar informações de posição do Mario e contagens
                this.ctx.fillStyle = 'white';
                this.ctx.font = '10px Arial';
                this.ctx.fillText(
                    `Mario: (${Math.floor(this.mario.x)},${Math.floor(this.mario.y)}) Camera: ${Math.floor(this.cameraX)}`,
                    10, 
                    20
                );
                
                // Adicionar contagens de blocos ao debug visual
                const blocksOnScreen = this.blocks.filter(block => {
                    if (block.broken) return false;
                    const drawX = block.x - this.cameraX;
                    return drawX >= -20 && drawX + block.width <= this.canvas.width + 20;
                }).length;
                
                const blocksInRange = this.blocks.filter(block => {
                    if (block.broken) return false;
                    const drawX = block.x - this.cameraX;
                    return drawX >= -100 && drawX <= this.canvas.width + 100;
                }).length;
                
                this.ctx.fillText(
                    `Blocos na tela: ${blocksOnScreen}, Na área de colisão: ${blocksInRange}, Total: ${this.blocks.length}`,
                    10, 
                    40
                );
            }

            // Sistema de debug removido - não é necessário para o jogo final
        }

        // Start the game
        window.addEventListener('load', () => {
            new MarioGame();
        });

        // Prevent scrolling on mobile
        document.addEventListener('touchmove', (e) => {
            e.preventDefault();
        }, { passive: false });
    </script>
</body>
</html>
